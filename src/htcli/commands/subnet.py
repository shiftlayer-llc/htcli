"""
Flattened subnet commands - 3-level hierarchy.
"""

import typer
from rich.console import Console
from typing import Optional
from ..models.requests import SubnetRegisterRequest
from ..utils.validation import (
    validate_subnet_name,
    validate_repo_url,
    validate_subnet_description,
    validate_stake_amount,
    validate_delegate_percentage,
    validate_epoch_value,
    validate_churn_limit,
    validate_max_nodes,
    validate_max_penalties,
    validate_key_types,
    validate_coldkey_addresses,
    validate_subnet_id,
    validate_address,
    validate_node_id,
)
from ..utils.formatting import (
    print_info,
    print_success,
    print_error,
    format_subnet_list,
    format_subnet_info,
    format_balance,
)
from ..utils.ownership import user_owns_subnet, require_user_keys, show_mine_filter_info
from ..dependencies import get_client

app = typer.Typer(name="subnet", help="Subnet operations")
console = Console()


@app.command()
def register(
    name: str = typer.Option(..., "--name", "-n", help="Unique name of the subnet"),
    repo: str = typer.Option(
        ..., "--repo", "-r", help="GitHub or similar link to source code"
    ),
    description: str = typer.Option(
        ..., "--description", "-d", help="Description of the subnet"
    ),
    misc: str = typer.Option("", "--misc", "-m", help="Miscellaneous information"),
    # Stake configuration
    min_stake: int = typer.Option(
        ..., "--min-stake", help="Minimum required stake balance to register a node"
    ),
    max_stake: int = typer.Option(
        ..., "--max-stake", help="Maximum allowable stake balance for a subnet node"
    ),
    delegate_stake_percentage: int = typer.Option(
        ...,
        "--delegate-percentage",
        help="Percentage ratio of emissions given to delegate stakers",
    ),
    # Epoch and timing configuration
    churn_limit: int = typer.Option(
        ..., "--churn-limit", help="Number of subnet activations per epoch"
    ),
    registration_queue_epochs: int = typer.Option(
        ...,
        "--queue-epochs",
        help="Number of epochs for registered nodes to be in queue before activation",
    ),
    activation_grace_epochs: int = typer.Option(
        ...,
        "--grace-epochs",
        help="Grace period epochs during which nodes can activate",
    ),
    queue_classification_epochs: int = typer.Option(
        ..., "--queue-classification", help="Number of epochs for queue classification"
    ),
    included_classification_epochs: int = typer.Option(
        ...,
        "--included-classification",
        help="Number of epochs for included classification",
    ),
    # Node configuration
    max_node_penalties: int = typer.Option(
        ..., "--max-penalties", help="Maximum penalties a node can have before removal"
    ),
    max_registered_nodes: int = typer.Option(
        ..., "--max-nodes", help="Maximum number of nodes in registration queue"
    ),
    initial_coldkeys: Optional[str] = typer.Option(
        None,
        "--initial-coldkeys",
        help="Comma-separated list of initial coldkey addresses",
    ),
    # Key types
    key_types: str = typer.Option(
        "Ed25519",
        "--key-types",
        help="Comma-separated key types (RSA,Ed25519,Secp256k1,ECDSA)",
    ),
    # Node removal system
    node_removal_system: str = typer.Option(
        "default", "--removal-system", help="Node removal system type"
    ),
    show_guidance: bool = typer.Option(
        True, "--guidance/--no-guidance", help="Show comprehensive guidance"
    ),
):
    """Register a new subnet with comprehensive guidance based on official specification."""
    client = get_client()

    # Show comprehensive guidance
    if show_guidance:
        from rich.panel import Panel

        guidance_panel = Panel(
            f"[bold cyan]üèóÔ∏è Subnet Registration Guide[/bold cyan]\n\n"
            f"This will register a new subnet on the Hypertensor network:\n\n"
            f"[bold]Subnet Details:[/bold]\n"
            f"‚Ä¢ Name: {name}\n"
            f"‚Ä¢ Repository: {repo}\n"
            f"‚Ä¢ Description: {description}\n\n"
            f"[bold]Stake Configuration:[/bold]\n"
            f"‚Ä¢ Min Stake: {min_stake} TENSOR\n"
            f"‚Ä¢ Max Stake: {max_stake} TENSOR\n"
            f"‚Ä¢ Delegate Percentage: {delegate_stake_percentage}%\n\n"
            f"[bold]Timing Configuration:[/bold]\n"
            f"‚Ä¢ Churn Limit: {churn_limit} activations/epoch\n"
            f"‚Ä¢ Queue Epochs: {registration_queue_epochs}\n"
            f"‚Ä¢ Grace Epochs: {activation_grace_epochs}\n\n"
            f"[yellow]‚ö†Ô∏è Important:[/yellow]\n"
            f"‚Ä¢ Registration fee is non-refundable\n"
            f"‚Ä¢ Registration period lasts 1 week\n"
            f"‚Ä¢ Initial coldkeys can register nodes during registration phase\n"
            f"‚Ä¢ Subnet becomes decentralized after activation",
            title="[bold yellow]üîê Subnet Registration[/bold yellow]",
            border_style="yellow",
        )
        console.print(guidance_panel)
        console.print()

        # Ask for confirmation
        if not typer.confirm("Do you want to proceed with subnet registration?"):
            print_info("Subnet registration cancelled.")
            return

    try:
        # Parse initial coldkeys if provided
        coldkeys = []
        if initial_coldkeys:
            coldkeys = [addr.strip() for addr in initial_coldkeys.split(",")]

        # Parse key types
        key_types_list = [kt.strip() for kt in key_types.split(",")]

        # Validate all inputs
        if not validate_subnet_name(name):
            print_error(
                "‚ùå Invalid subnet name. Use alphanumeric characters, hyphens, underscores, and spaces only."
            )
            raise typer.Exit(1)

        if not validate_repo_url(repo):
            print_error("‚ùå Invalid repository URL. Must be a valid HTTP/HTTPS URL.")
            raise typer.Exit(1)

        if not validate_subnet_description(description):
            print_error(
                "‚ùå Invalid description. Must be between 10 and 1000 characters."
            )
            raise typer.Exit(1)

        if not validate_stake_amount(min_stake):
            print_error(
                "‚ùå Invalid minimum stake amount. Must be positive and reasonable."
            )
            raise typer.Exit(1)

        if not validate_stake_amount(max_stake):
            print_error(
                "‚ùå Invalid maximum stake amount. Must be positive and reasonable."
            )
            raise typer.Exit(1)

        if min_stake >= max_stake:
            print_error("‚ùå Maximum stake must be greater than minimum stake.")
            raise typer.Exit(1)

        if not validate_delegate_percentage(delegate_stake_percentage):
            print_error("‚ùå Invalid delegate percentage. Must be between 0 and 100.")
            raise typer.Exit(1)

        if not validate_churn_limit(churn_limit):
            print_error("‚ùå Invalid churn limit. Must be between 1 and 1000.")
            raise typer.Exit(1)

        if not validate_epoch_value(registration_queue_epochs):
            print_error(
                "‚ùå Invalid registration queue epochs. Must be between 0 and 1,000,000."
            )
            raise typer.Exit(1)

        if not validate_epoch_value(activation_grace_epochs):
            print_error(
                "‚ùå Invalid activation grace epochs. Must be between 0 and 1,000,000."
            )
            raise typer.Exit(1)

        if not validate_epoch_value(queue_classification_epochs):
            print_error(
                "‚ùå Invalid queue classification epochs. Must be between 0 and 1,000,000."
            )
            raise typer.Exit(1)

        if not validate_epoch_value(included_classification_epochs):
            print_error(
                "‚ùå Invalid included classification epochs. Must be between 0 and 1,000,000."
            )
            raise typer.Exit(1)

        if not validate_max_penalties(max_node_penalties):
            print_error("‚ùå Invalid max node penalties. Must be between 1 and 100.")
            raise typer.Exit(1)

        if not validate_max_nodes(max_registered_nodes):
            print_error(
                "‚ùå Invalid max registered nodes. Must be between 1 and 10,000."
            )
            raise typer.Exit(1)

        if not validate_key_types(key_types_list):
            print_error(
                "‚ùå Invalid key types. Supported: RSA, Ed25519, Secp256k1, ECDSA."
            )
            raise typer.Exit(1)

        if not validate_coldkey_addresses(coldkeys):
            print_error("‚ùå Invalid coldkey addresses. Must be valid SS58 addresses.")
            raise typer.Exit(1)

        request = SubnetRegisterRequest(
            name=name,
            repo=repo,
            description=description,
            misc=misc,
            min_stake=min_stake,
            max_stake=max_stake,
            delegate_stake_percentage=delegate_stake_percentage,
            churn_limit=churn_limit,
            registration_queue_epochs=registration_queue_epochs,
            activation_grace_epochs=activation_grace_epochs,
            queue_classification_epochs=queue_classification_epochs,
            included_classification_epochs=included_classification_epochs,
            max_node_penalties=max_node_penalties,
            max_registered_nodes=max_registered_nodes,
            initial_coldkeys=coldkeys,
            key_types=key_types_list,
            node_removal_system=node_removal_system,
        )

        response = client.register_subnet(request)
        print_success("‚úÖ Subnet registered successfully!")
        console.print(f"Transaction: {response.transaction_hash}")
        if response.block_number:
            console.print(f"Block: #{response.block_number}")
    except Exception as e:
        print_error(f"Failed to register subnet: {str(e)}")
        raise typer.Exit(1)


@app.command()
def activate(
    subnet_id: int = typer.Option(
        ..., "--subnet-id", "-s", help="Subnet ID to activate"
    ),
    key_name: Optional[str] = typer.Option(
        None, "--key-name", "-k", help="Key name for signing (required for owner)"
    ),
    show_guidance: bool = typer.Option(
        True, "--guidance/--no-guidance", help="Show comprehensive guidance"
    ),
):
    """Activate a registered subnet with comprehensive guidance based on official specification."""
    client = get_client()

    # Show comprehensive guidance
    if show_guidance:
        from rich.panel import Panel

        guidance_panel = Panel(
            f"[bold cyan]üöÄ Subnet Activation Guide[/bold cyan]\n\n"
            f"This will activate subnet {subnet_id} on the Hypertensor network:\n\n"
            f"[bold]Requirements for Activation:[/bold]\n"
            f"‚Ä¢ Must have minimum required subnet nodes (MinSubnetNodes)\n"
            f"‚Ä¢ Must have floating minimum delegate stake balance\n"
            f"‚Ä¢ Must meet MinSubnetDelegateStakeFactor percentage of total supply\n"
            f"‚Ä¢ Owner must sign the activation transaction\n\n"
            f"[bold]What Happens After Activation:[/bold]\n"
            f"‚Ä¢ Subnet gets an open slot for rewards distribution\n"
            f"‚Ä¢ Initial coldkeys list is removed\n"
            f"‚Ä¢ Anyone can register nodes (decentralized)\n"
            f"‚Ä¢ Subnet starts earning and distributing rewards\n\n"
            f"[yellow]‚ö†Ô∏è Important:[/yellow]\n"
            f"‚Ä¢ Only the subnet owner can activate\n"
            f"‚Ä¢ If requirements aren't met, subnet is deactivated and removed\n"
            f"‚Ä¢ Delegate stake balance must be maintained each epoch",
            title="[bold yellow]üîê Subnet Activation[/bold yellow]",
            border_style="yellow",
        )
        console.print(guidance_panel)
        console.print()

        # Ask for confirmation
        if not typer.confirm("Do you want to proceed with subnet activation?"):
            print_info("Subnet activation cancelled.")
            return

    try:
        # Check if key_name is provided (required for owner activation)
        if not key_name:
            print_error(
                "‚ùå Key name is required for subnet activation. Use --key-name to specify your signing key."
            )
            raise typer.Exit(1)

        # Get subnet info to check ownership and requirements
        subnet_response = client.get_subnet_data(subnet_id)
        if not subnet_response.success:
            print_error(
                f"‚ùå Failed to get subnet information: {subnet_response.message}"
            )
            raise typer.Exit(1)

        subnet_info = subnet_response.data

        # Check if subnet exists
        if not subnet_info.get("exists", False):
            print_error(f"‚ùå Subnet {subnet_id} does not exist.")
            raise typer.Exit(1)

        # Check if subnet is already activated
        if subnet_info.get("activated", False):
            print_error(f"‚ùå Subnet {subnet_id} is already activated.")
            raise typer.Exit(1)

        # Check ownership (user must be the owner to activate)
        from ..utils.ownership import get_user_addresses, user_owns_subnet

        user_addresses = get_user_addresses()
        if not user_owns_subnet(subnet_info, user_addresses):
            print_error(
                f"‚ùå You are not the owner of subnet {subnet_id}. Only the owner can activate a subnet."
            )
            raise typer.Exit(1)

        print_info(f"üîÑ Activating subnet {subnet_id}...")
        print_info(f"üìã Checking activation requirements...")

        # Check activation requirements
        requirements = client.check_subnet_activation_requirements(subnet_id)
        
        # Display requirements status
        if requirements["errors"]:
            console.print(Panel(
                f"[bold red]‚ùå Activation Requirements Not Met[/bold red]\n\n"
                f"The following requirements must be met before activation:\n\n"
                f"{chr(10).join([f'‚Ä¢ [red]{error}[/red]' for error in requirements['errors']])}\n\n"
                f"[yellow]üìã Required Actions:[/yellow]\n"
                f"‚Ä¢ Address all requirements above\n"
                f"‚Ä¢ Ensure subnet is in registration phase\n"
                f"‚Ä¢ Meet minimum node and stake requirements\n"
                f"‚Ä¢ Check network consensus status\n\n"
                f"[yellow]üí° Tip:[/yellow]\n"
                f"‚Ä¢ Use 'htcli subnet info --subnet-id {subnet_id}' to check current status\n"
                f"‚Ä¢ Add more nodes or delegate stake as needed\n"
                f"‚Ä¢ Wait for network consensus to be ready",
                title="Activation Requirements Failed",
                border_style="red"
            ))
            raise typer.Exit(1)
        
        if requirements["warnings"]:
            console.print(Panel(
                f"[bold yellow]‚ö†Ô∏è Activation Warnings[/bold yellow]\n\n"
                f"The following warnings were found:\n\n"
                f"{chr(10).join([f'‚Ä¢ [yellow]{warning}[/yellow]' for warning in requirements['warnings']])}\n\n"
                f"[yellow]üìã Recommendations:[/yellow]\n"
                f"‚Ä¢ Consider addressing warnings for better stability\n"
                f"‚Ä¢ Activation can proceed but may not be optimal\n"
                f"‚Ä¢ Monitor subnet performance after activation\n\n"
                f"[yellow]üí° Tip:[/yellow]\n"
                f"‚Ä¢ Add more nodes for better stability\n"
                f"‚Ä¢ Increase delegate stake for better performance\n"
                f"‚Ä¢ Monitor network conditions",
                title="Activation Warnings",
                border_style="yellow"
            ))

        # Show requirements summary
        details = requirements["details"]
        console.print(Panel(
            f"[bold green]‚úÖ Activation Requirements Met[/bold green]\n\n"
            f"[bold]Requirements Summary:[/bold]\n"
            f"‚Ä¢ [green]Minimum Nodes[/green]: {details.get('min_nodes', 'N/A')} (Current: {details.get('current_nodes', 'N/A')})\n"
            f"‚Ä¢ [green]Minimum Delegate Stake[/green]: {format_balance(details.get('min_delegate_stake', 0))} (Current: {format_balance(details.get('current_delegate_stake', 0))})\n"
            f"‚Ä¢ [green]Initial Coldkeys[/green]: {details.get('initial_coldkeys', 0)}\n"
            f"‚Ä¢ [green]Stake Factor[/green]: {'‚úÖ Met' if details.get('stake_factor', {}).get('met', False) else '‚ùå Not Met'}\n"
            f"‚Ä¢ [green]Network Consensus[/green]: {'‚úÖ Ready' if details.get('consensus', {}).get('met', False) else '‚ùå Not Ready'}\n\n"
            f"[yellow]üí° Proceeding with activation...[/yellow]",
            title="Requirements Check Passed",
            border_style="green"
        ))

        response = client.activate_subnet(subnet_id, key_name=key_name)

        if response.success:
            print_success(f"‚úÖ Subnet {subnet_id} activated successfully!")
            console.print(
                f"üìÑ Transaction Hash: [bold cyan]{response.transaction_hash}[/bold cyan]"
            )
            if response.block_number:
                console.print(
                    f"üì¶ Block Number: [bold cyan]#{response.block_number}[/bold cyan]"
                )

            console.print(Panel(
                f"[bold green]üöÄ Subnet Activation Complete![/bold green]\n\n"
                f"Subnet {subnet_id} is now active and:\n"
                f"‚Ä¢ Has an open slot for rewards distribution\n"
                f"‚Ä¢ Initial coldkeys have been removed\n"
                f"‚Ä¢ Anyone can now register nodes\n"
                f"‚Ä¢ Subnet is earning and distributing rewards\n\n"
                f"[yellow]üìä Monitor your subnet:[/yellow]\n"
                f"Use: [bold]htcli subnet info --subnet-id {subnet_id}[/bold]",
                title="Activation Success",
                border_style="green"
            ))
        else:
            print_error(f"‚ùå Failed to activate subnet: {response.message}")
            raise typer.Exit(1)

    except Exception as e:
        print_error(f"‚ùå Failed to activate subnet: {str(e)}")
        raise typer.Exit(1)


@app.command()
def list(
    format_type: str = typer.Option(
        "table", "--format", "-f", help="Output format (table/json)"
    )
):
    """List subnets. Use --mine flag globally to show only your subnets."""
    client = get_client()

    # Check if --mine filter is enabled globally
    config = client.config
    filter_mine = getattr(config.filter, "mine", False)

    try:
        response = client.get_subnets_data()
        if response.success:
            subnets = response.data.get("subnets", [])
            original_count = len(subnets)

            # Apply --mine filtering if enabled
            if filter_mine:
                user_addresses = require_user_keys()

                # Enhance subnets with ownership information
                enhanced_subnets = []
                for subnet in subnets:
                    subnet_id = subnet.get("subnet_id")
                    if subnet_id:
                        # Get detailed subnet data to check ownership
                        detail_response = client.get_subnet_data(subnet_id)
                        if detail_response.success:
                            subnet_detail = detail_response.data
                            # Check if user owns this subnet
                            if user_owns_subnet(subnet_detail, user_addresses):
                                enhanced_subnets.append(
                                    {
                                        **subnet,
                                        "owner": subnet_detail.get("owner", ""),
                                        "is_mine": True,
                                    }
                                )

                subnets = enhanced_subnets
                show_mine_filter_info(user_addresses, len(subnets), original_count)

            if format_type == "json":
                console.print_json(data=subnets)
            else:
                format_subnet_list(subnets)

        else:
            print_error(f"Failed to retrieve subnets: {response.message}")
    except Exception as e:
        print_error(f"Failed to list subnets: {str(e)}")
        raise typer.Exit(1)


@app.command()
def info(
    subnet_id: int = typer.Option(..., "--subnet-id", "-s", help="Subnet ID"),
    format_type: str = typer.Option(
        "table", "--format", "-f", help="Output format (table/json)"
    ),
):
    """Get detailed information about a subnet."""
    client = get_client()

    try:
        response = client.get_subnet_data(subnet_id)
        if response.success:
            subnet_info = response.data
            if format_type == "json":
                console.print_json(data=subnet_info)
            else:
                format_subnet_info(subnet_info)
        else:
            print_error(f"Failed to retrieve subnet info: {response.message}")
    except Exception as e:
        print_error(f"Failed to get subnet info: {str(e)}")
        raise typer.Exit(1)


@app.command()
def pause(
    subnet_id: int = typer.Option(..., "--subnet-id", "-s", help="Subnet ID to pause"),
    key_name: Optional[str] = typer.Option(
        None, "--key-name", "-k", help="Key name for signing (required for owner)"
    ),
    show_guidance: bool = typer.Option(
        True, "--guidance/--no-guidance", help="Show comprehensive guidance"
    ),
):
    """Pause an active subnet with comprehensive guidance based on official specification."""
    client = get_client()

    # Show comprehensive guidance
    if show_guidance:
        from rich.panel import Panel

        guidance_panel = Panel(
            f"[bold cyan]‚è∏Ô∏è Subnet Pause Guide[/bold cyan]\n\n"
            f"This will pause subnet {subnet_id} on the Hypertensor network:\n\n"
            f"[bold]What Happens When Paused:[/bold]\n"
            f"‚Ä¢ All subnet functionality is paused on-chain\n"
            f"‚Ä¢ Validator election stops\n"
            f"‚Ä¢ Emissions distribution stops\n"
            f"‚Ä¢ Subnet becomes inactive temporarily\n\n"
            f"[bold]Important Limitations:[/bold]\n"
            f"‚Ä¢ Maximum pause duration: 4 days\n"
            f"‚Ä¢ Only subnet owner can pause\n"
            f"‚Ä¢ Penalties increase each epoch if not unpaused\n"
            f"‚Ä¢ Subnet will be removed if max penalties reached\n\n"
            f"[yellow]‚ö†Ô∏è Warning:[/yellow]\n"
            f"‚Ä¢ Pausing affects all subnet operations\n"
            f"‚Ä¢ Stakeholders may lose rewards during pause\n"
            f"‚Ä¢ Plan pause duration carefully",
            title="[bold yellow]‚è∏Ô∏è Subnet Pause[/bold yellow]",
            border_style="yellow",
        )
        console.print(guidance_panel)
        console.print()

        # Ask for confirmation
        if not typer.confirm("Do you want to proceed with pausing the subnet?"):
            print_info("Subnet pause cancelled.")
            return

    try:
        # Check if key_name is provided (required for owner operations)
        if not key_name:
            print_error(
                "‚ùå Key name is required for subnet pause. Use --key-name to specify your signing key."
            )
            raise typer.Exit(1)

        # Get subnet info to check ownership and status
        subnet_response = client.get_subnet_data(subnet_id)
        if not subnet_response.success:
            print_error(
                f"‚ùå Failed to get subnet information: {subnet_response.message}"
            )
            raise typer.Exit(1)

        subnet_info = subnet_response.data

        # Check if subnet exists
        if not subnet_info.get("exists", False):
            print_error(f"‚ùå Subnet {subnet_id} does not exist.")
            raise typer.Exit(1)

        # Check if subnet is active (can only pause active subnets)
        if not subnet_info.get("activated", False):
            print_error(
                f"‚ùå Subnet {subnet_id} is not active. Only active subnets can be paused."
            )
            raise typer.Exit(1)

        # Check if subnet is already paused
        if subnet_info.get("paused", False):
            print_error(f"‚ùå Subnet {subnet_id} is already paused.")
            raise typer.Exit(1)

        # Check ownership (user must be the owner to pause)
        from ..utils.ownership import get_user_addresses, user_owns_subnet

        user_addresses = get_user_addresses()
        if not user_owns_subnet(subnet_info, user_addresses):
            print_error(
                f"‚ùå You are not the owner of subnet {subnet_id}. Only the owner can pause a subnet."
            )
            raise typer.Exit(1)

        print_info(f"‚è∏Ô∏è Pausing subnet {subnet_id}...")

        response = client.pause_subnet(subnet_id, key_name=key_name)

        if response.success:
            print_success(f"‚úÖ Subnet {subnet_id} paused successfully!")
            console.print(
                f"üìÑ Transaction Hash: [bold cyan]{response.transaction_hash}[/bold cyan]"
            )
            if response.block_number:
                console.print(
                    f"üì¶ Block Number: [bold cyan]#{response.block_number}[/bold cyan]"
                )

            console.print(Panel(
                f"[bold yellow]‚è∏Ô∏è Subnet Paused Successfully![/bold yellow]\n\n"
                f"Subnet {subnet_id} is now paused and:\n"
                f"‚Ä¢ All functionality is suspended\n"
                f"‚Ä¢ Validator election stopped\n"
                f"‚Ä¢ Emissions distribution paused\n"
                f"‚Ä¢ Penalties will increase if not unpaused\n\n"
                f"[yellow]üìä Monitor your subnet:[/yellow]\n"
                f"Use: [bold]htcli subnet info --subnet-id {subnet_id}[/bold]\n\n"
                f"[yellow]üîÑ To unpause:[/yellow]\n"
                f"Use: [bold]htcli subnet unpause --subnet-id {subnet_id} --key-name {key_name}[/bold]",
                title="Pause Success",
                border_style="yellow"
            ))
        else:
            print_error(f"‚ùå Failed to pause subnet: {response.message}")
            raise typer.Exit(1)

    except Exception as e:
        print_error(f"‚ùå Failed to pause subnet: {str(e)}")
        raise typer.Exit(1)


@app.command()
def unpause(
    subnet_id: int = typer.Option(
        ..., "--subnet-id", "-s", help="Subnet ID to unpause"
    ),
    key_name: Optional[str] = typer.Option(
        None, "--key-name", "-k", help="Key name for signing (required for owner)"
    ),
    show_guidance: bool = typer.Option(
        True, "--guidance/--no-guidance", help="Show comprehensive guidance"
    ),
):
    """Unpause a paused subnet with comprehensive guidance based on official specification."""
    client = get_client()

    # Show comprehensive guidance
    if show_guidance:
        from rich.panel import Panel

        guidance_panel = Panel(
            f"[bold cyan]‚ñ∂Ô∏è Subnet Unpause Guide[/bold cyan]\n\n"
            f"This will unpause subnet {subnet_id} on the Hypertensor network:\n\n"
            f"[bold]What Happens When Unpaused:[/bold]\n"
            f"‚Ä¢ Subnet resumes consensus on next epoch\n"
            f"‚Ä¢ Validator election resumes\n"
            f"‚Ä¢ Emissions distribution resumes\n"
            f"‚Ä¢ Registered nodes are pushed back in queue\n"
            f"‚Ä¢ Idle nodes are not affected\n\n"
            f"[bold]Queue Impact:[/bold]\n"
            f"‚Ä¢ Registered nodes: pushed back by pause duration\n"
            f"‚Ä¢ Idle nodes: no change to queue position\n"
            f"‚Ä¢ New consensus begins immediately\n\n"
            f"[yellow]‚úÖ Benefits:[/yellow]\n"
            f"‚Ä¢ Stops penalty accumulation\n"
            f"‚Ä¢ Resumes normal operations\n"
            f"‚Ä¢ Stakeholders can earn rewards again",
            title="[bold green]‚ñ∂Ô∏è Subnet Unpause[/bold green]",
            border_style="green",
        )
        console.print(guidance_panel)
        console.print()

        # Ask for confirmation
        if not typer.confirm("Do you want to proceed with unpausing the subnet?"):
            print_info("Subnet unpause cancelled.")
            return

    try:
        # Check if key_name is provided (required for owner operations)
        if not key_name:
            print_error(
                "‚ùå Key name is required for subnet unpause. Use --key-name to specify your signing key."
            )
            raise typer.Exit(1)

        # Get subnet info to check ownership and status
        subnet_response = client.get_subnet_data(subnet_id)
        if not subnet_response.success:
            print_error(
                f"‚ùå Failed to get subnet information: {subnet_response.message}"
            )
            raise typer.Exit(1)

        subnet_info = subnet_response.data

        # Check if subnet exists
        if not subnet_info.get("exists", False):
            print_error(f"‚ùå Subnet {subnet_id} does not exist.")
            raise typer.Exit(1)

        # Check if subnet is paused (can only unpause paused subnets)
        if not subnet_info.get("paused", False):
            print_error(
                f"‚ùå Subnet {subnet_id} is not paused. Only paused subnets can be unpaused."
            )
            raise typer.Exit(1)

        # Check ownership (user must be the owner to unpause)
        from ..utils.ownership import get_user_addresses, user_owns_subnet

        user_addresses = get_user_addresses()
        if not user_owns_subnet(subnet_info, user_addresses):
            print_error(
                f"‚ùå You are not the owner of subnet {subnet_id}. Only the owner can unpause a subnet."
            )
            raise typer.Exit(1)

        print_info(f"‚ñ∂Ô∏è Unpausing subnet {subnet_id}...")

        response = client.unpause_subnet(subnet_id, key_name=key_name)

        if response.success:
            print_success(f"‚úÖ Subnet {subnet_id} unpaused successfully!")
            console.print(
                f"üìÑ Transaction Hash: [bold cyan]{response.transaction_hash}[/bold cyan]"
            )
            if response.block_number:
                console.print(
                    f"üì¶ Block Number: [bold cyan]#{response.block_number}[/bold cyan]"
                )

            console.print(Panel(
                f"[bold green]‚ñ∂Ô∏è Subnet Unpaused Successfully![/bold green]\n\n"
                f"Subnet {subnet_id} is now active and:\n"
                f"‚Ä¢ Consensus resumes on next epoch\n"
                f"‚Ä¢ Validator election active\n"
                f"‚Ä¢ Emissions distribution resumed\n"
                f"‚Ä¢ Registered nodes pushed back in queue\n"
                f"‚Ä¢ Idle nodes unaffected\n\n"
                f"[yellow]üìä Monitor your subnet:[/yellow]\n"
                f"Use: [bold]htcli subnet info --subnet-id {subnet_id}[/bold]",
                title="Unpause Success",
                border_style="green"
            ))
        else:
            print_error(f"‚ùå Failed to unpause subnet: {response.message}")
            raise typer.Exit(1)

    except Exception as e:
        print_error(f"‚ùå Failed to unpause subnet: {str(e)}")
        raise typer.Exit(1)


@app.command()
def remove(
    subnet_id: int = typer.Option(..., "--subnet-id", "-s", help="Subnet ID to remove"),
    show_guidance: bool = typer.Option(
        True, "--guidance/--no-guidance", help="Show comprehensive guidance"
    ),
):
    """Remove a subnet with comprehensive guidance."""
    client = get_client()

    try:
        response = client.remove_subnet(subnet_id)
        print_success(f"‚úÖ Subnet {subnet_id} removed successfully!")
        console.print(f"Transaction: {response.transaction_hash}")
        if response.block_number:
            console.print(f"Block: #{response.block_number}")
    except Exception as e:
        print_error(f"Failed to remove subnet: {str(e)}")
        raise typer.Exit(1)


# ============================================================================
# SUBNET OWNER OPERATIONS
# ============================================================================

@app.command()
def owner_update_name(
    subnet_id: int = typer.Option(..., "--subnet-id", "-s", help="Subnet ID"),
    name: str = typer.Option(..., "--name", "-n", help="New subnet name"),
    key_name: Optional[str] = typer.Option(
        None, "--key-name", "-k", help="Key name for signing (required for owner)"
    ),
    show_guidance: bool = typer.Option(
        True, "--guidance/--no-guidance", help="Show comprehensive guidance"
    ),
):
    """Update the unique name of a subnet (owner only)."""
    client = get_client()

    # Show comprehensive guidance
    if show_guidance:
        from rich.panel import Panel
        guidance_panel = Panel(
            f"[bold cyan]üìù Update Subnet Name Guide[/bold cyan]\n\n"
            f"This will update the name of subnet {subnet_id} to '{name}':\n\n"
            f"[bold]What This Does:[/bold]\n"
            f"‚Ä¢ Changes the unique name of your subnet\n"
            f"‚Ä¢ Updates the on-chain subnet information\n"
            f"‚Ä¢ Affects how your subnet appears in listings\n"
            f"‚Ä¢ Requires owner authentication\n\n"
            f"[bold]Requirements:[/bold]\n"
            f"‚Ä¢ You must be the subnet owner\n"
            f"‚Ä¢ Name must be unique across all subnets\n"
            f"‚Ä¢ Valid signing key required\n\n"
            f"[yellow]‚ö†Ô∏è Important:[/yellow]\n"
            f"‚Ä¢ This is a permanent change\n"
            f"‚Ä¢ Name changes affect subnet discoverability\n"
            f"‚Ä¢ Consider the impact on your subnet's branding",
            title="[bold blue]üìù Update Subnet Name[/bold blue]",
            border_style="blue"
        )
        console.print(guidance_panel)
        console.print()

        # Ask for confirmation
        if not typer.confirm(f"Update subnet {subnet_id} name to '{name}'?"):
            print_info("Subnet name update cancelled.")
            return

    # Validate inputs
    if not validate_subnet_id(subnet_id):
        print_error("‚ùå Invalid subnet ID. Must be a positive integer.")
        raise typer.Exit(1)

    if not validate_subnet_name(name):
        print_error("‚ùå Invalid subnet name.")
        raise typer.Exit(1)

    # Check if key_name is provided (required for owner operations)
    if not key_name:
        print_error("‚ùå Key name is required for subnet owner operations. Use --key-name to specify your signing key.")
        raise typer.Exit(1)

    try:
        # Check ownership (user must be the owner to update)
        subnet_response = client.get_subnet_data(subnet_id)
        if not subnet_response.success:
            print_error(f"‚ùå Failed to get subnet information: {subnet_response.message}")
            raise typer.Exit(1)

        subnet_info = subnet_response.data

        # Check if subnet exists
        if not subnet_info.get('exists', False):
            print_error(f"‚ùå Subnet {subnet_id} does not exist.")
            raise typer.Exit(1)

        # Check ownership (user must be the owner to update)
        from ..utils.ownership import get_user_addresses, user_owns_subnet
        user_addresses = get_user_addresses()
        if not user_owns_subnet(subnet_info, user_addresses):
            print_error(f"‚ùå You are not the owner of subnet {subnet_id}. Only the owner can update subnet information.")
            raise typer.Exit(1)

        print_info(f"üìù Updating subnet {subnet_id} name to '{name}'...")

        response = client.owner_update_name(subnet_id, name, key_name=key_name)

        if response.success:
            print_success(f"‚úÖ Subnet {subnet_id} name updated to '{name}' successfully!")
            console.print(f"üìÑ Transaction Hash: [bold cyan]{response.transaction_hash}[/bold cyan]")
            if response.block_number:
                console.print(f"üì¶ Block Number: [bold cyan]#{response.block_number}[/bold cyan]")

            console.print(Panel(
                f"[bold green]üìù Name Update Complete![/bold green]\n\n"
                f"Subnet {subnet_id} is now named '{name}'.\n"
                f"‚Ä¢ On-chain information updated\n"
                f"‚Ä¢ Subnet discoverability improved\n"
                f"‚Ä¢ Branding updated successfully\n\n"
                f"[yellow]üìä Verify Changes:[/yellow]\n"
                f"Use: [bold]htcli subnet info --subnet-id {subnet_id}[/bold]",
                title="Name Update Success",
                border_style="green"
            ))
        else:
            print_error(f"‚ùå Failed to update subnet name: {response.message}")
            raise typer.Exit(1)

    except Exception as e:
        print_error(f"‚ùå Failed to update subnet name: {str(e)}")
        raise typer.Exit(1)


@app.command()
def owner_update_repo(
    subnet_id: int = typer.Option(..., "--subnet-id", "-s", help="Subnet ID"),
    repo: str = typer.Option(..., "--repo", "-r", help="New repository URL"),
    key_name: Optional[str] = typer.Option(
        None, "--key-name", "-k", help="Key name for signing (required for owner)"
    ),
    show_guidance: bool = typer.Option(
        True, "--guidance/--no-guidance", help="Show comprehensive guidance"
    ),
):
    """Update the repository URL of a subnet (owner only)."""
    client = get_client()

    # Show comprehensive guidance
    if show_guidance:
        from rich.panel import Panel
        guidance_panel = Panel(
            f"[bold cyan]üîó Update Subnet Repository Guide[/bold cyan]\n\n"
            f"This will update the repository URL of subnet {subnet_id} to '{repo}':\n\n"
            f"[bold]What This Does:[/bold]\n"
            f"‚Ä¢ Updates the open-source code repository link\n"
            f"‚Ä¢ Changes where users can find your subnet's source code\n"
            f"‚Ä¢ Updates the on-chain subnet information\n"
            f"‚Ä¢ Requires owner authentication\n\n"
            f"[bold]Requirements:[/bold]\n"
            f"‚Ä¢ You must be the subnet owner\n"
            f"‚Ä¢ Repository URL must be valid and accessible\n"
            f"‚Ä¢ Valid signing key required\n\n"
            f"[yellow]‚ö†Ô∏è Important:[/yellow]\n"
            f"‚Ä¢ This affects code discoverability\n"
            f"‚Ä¢ Ensure the repository is public and accessible\n"
            f"‚Ä¢ Consider the impact on developer adoption",
            title="[bold blue]üîó Update Subnet Repository[/bold blue]",
            border_style="blue"
        )
        console.print(guidance_panel)
        console.print()

        # Ask for confirmation
        if not typer.confirm(f"Update subnet {subnet_id} repository to '{repo}'?"):
            print_info("Subnet repository update cancelled.")
            return

    # Validate inputs
    if not validate_subnet_id(subnet_id):
        print_error("‚ùå Invalid subnet ID. Must be a positive integer.")
        raise typer.Exit(1)

    if not validate_repo_url(repo):
        print_error("‚ùå Invalid repository URL.")
        raise typer.Exit(1)

    # Check if key_name is provided (required for owner operations)
    if not key_name:
        print_error("‚ùå Key name is required for subnet owner operations. Use --key-name to specify your signing key.")
        raise typer.Exit(1)

    try:
        # Check ownership (user must be the owner to update)
        subnet_response = client.get_subnet_data(subnet_id)
        if not subnet_response.success:
            print_error(f"‚ùå Failed to get subnet information: {subnet_response.message}")
            raise typer.Exit(1)

        subnet_info = subnet_response.data

        # Check if subnet exists
        if not subnet_info.get('exists', False):
            print_error(f"‚ùå Subnet {subnet_id} does not exist.")
            raise typer.Exit(1)

        # Check ownership (user must be the owner to update)
        from ..utils.ownership import get_user_addresses, user_owns_subnet
        user_addresses = get_user_addresses()
        if not user_owns_subnet(subnet_info, user_addresses):
            print_error(f"‚ùå You are not the owner of subnet {subnet_id}. Only the owner can update subnet information.")
            raise typer.Exit(1)

        print_info(f"üîó Updating subnet {subnet_id} repository to '{repo}'...")

        response = client.owner_update_repo(subnet_id, repo, key_name=key_name)

        if response.success:
            print_success(f"‚úÖ Subnet {subnet_id} repository updated to '{repo}' successfully!")
            console.print(f"üìÑ Transaction Hash: [bold cyan]{response.transaction_hash}[/bold cyan]")
            if response.block_number:
                console.print(f"üì¶ Block Number: [bold cyan]#{response.block_number}[/bold cyan]")

            console.print(Panel(
                f"[bold green]üîó Repository Update Complete![/bold green]\n\n"
                f"Subnet {subnet_id} repository is now '{repo}'.\n"
                f"‚Ä¢ Source code location updated\n"
                f"‚Ä¢ Developer accessibility improved\n"
                f"‚Ä¢ On-chain information updated\n\n"
                f"[yellow]üìä Verify Changes:[/yellow]\n"
                f"Use: [bold]htcli subnet info --subnet-id {subnet_id}[/bold]",
                title="Repository Update Success",
                border_style="green"
            ))
        else:
            print_error(f"‚ùå Failed to update subnet repository: {response.message}")
            raise typer.Exit(1)

    except Exception as e:
        print_error(f"‚ùå Failed to update subnet repository: {str(e)}")
        raise typer.Exit(1)


@app.command()
def owner_update_description(
    subnet_id: int = typer.Option(..., "--subnet-id", "-s", help="Subnet ID"),
    description: str = typer.Option(..., "--description", "-d", help="New subnet description"),
    key_name: Optional[str] = typer.Option(
        None, "--key-name", "-k", help="Key name for signing (required for owner)"
    ),
    show_guidance: bool = typer.Option(
        True, "--guidance/--no-guidance", help="Show comprehensive guidance"
    ),
):
    """Update the description of a subnet (owner only)."""
    client = get_client()

    # Show comprehensive guidance
    if show_guidance:
        from rich.panel import Panel
        guidance_panel = Panel(
            f"[bold cyan]üìÑ Update Subnet Description Guide[/bold cyan]\n\n"
            f"This will update the description of subnet {subnet_id}:\n\n"
            f"[bold]What This Does:[/bold]\n"
            f"‚Ä¢ Updates the subnet's description\n"
            f"‚Ä¢ Changes how your subnet is presented to users\n"
            f"‚Ä¢ Updates the on-chain subnet information\n"
            f"‚Ä¢ Requires owner authentication\n\n"
            f"[bold]Requirements:[/bold]\n"
            f"‚Ä¢ You must be the subnet owner\n"
            f"‚Ä¢ Description should be clear and informative\n"
            f"‚Ä¢ Valid signing key required\n\n"
            f"[yellow]‚ö†Ô∏è Important:[/yellow]\n"
            f"‚Ä¢ This affects user understanding of your subnet\n"
            f"‚Ä¢ Make the description clear and compelling\n"
            f"‚Ä¢ Consider the impact on adoption",
            title="[bold blue]üìÑ Update Subnet Description[/bold blue]",
            border_style="blue"
        )
        console.print(guidance_panel)
        console.print()

        # Ask for confirmation
        if not typer.confirm(f"Update subnet {subnet_id} description?"):
            print_info("Subnet description update cancelled.")
            return

    # Validate inputs
    if not validate_subnet_id(subnet_id):
        print_error("‚ùå Invalid subnet ID. Must be a positive integer.")
        raise typer.Exit(1)

    if not validate_subnet_description(description):
        print_error("‚ùå Invalid subnet description.")
        raise typer.Exit(1)

    # Check if key_name is provided (required for owner operations)
    if not key_name:
        print_error("‚ùå Key name is required for subnet owner operations. Use --key-name to specify your signing key.")
        raise typer.Exit(1)

    try:
        # Check ownership (user must be the owner to update)
        subnet_response = client.get_subnet_data(subnet_id)
        if not subnet_response.success:
            print_error(f"‚ùå Failed to get subnet information: {subnet_response.message}")
            raise typer.Exit(1)

        subnet_info = subnet_response.data

        # Check if subnet exists
        if not subnet_info.get('exists', False):
            print_error(f"‚ùå Subnet {subnet_id} does not exist.")
            raise typer.Exit(1)

        # Check ownership (user must be the owner to update)
        from ..utils.ownership import get_user_addresses, user_owns_subnet
        user_addresses = get_user_addresses()
        if not user_owns_subnet(subnet_info, user_addresses):
            print_error(f"‚ùå You are not the owner of subnet {subnet_id}. Only the owner can update subnet information.")
            raise typer.Exit(1)

        print_info(f"üìÑ Updating subnet {subnet_id} description...")

        response = client.owner_update_description(subnet_id, description, key_name=key_name)

        if response.success:
            print_success(f"‚úÖ Subnet {subnet_id} description updated successfully!")
            console.print(f"üìÑ Transaction Hash: [bold cyan]{response.transaction_hash}[/bold cyan]")
            if response.block_number:
                console.print(f"üì¶ Block Number: [bold cyan]#{response.block_number}[/bold cyan]")

            console.print(Panel(
                f"[bold green]üìÑ Description Update Complete![/bold green]\n\n"
                f"Subnet {subnet_id} description has been updated.\n"
                f"‚Ä¢ On-chain information updated\n"
                f"‚Ä¢ User understanding improved\n"
                f"‚Ä¢ Subnet presentation enhanced\n\n"
                f"[yellow]üìä Verify Changes:[/yellow]\n"
                f"Use: [bold]htcli subnet info --subnet-id {subnet_id}[/bold]",
                title="Description Update Success",
                border_style="green"
            ))
        else:
            print_error(f"‚ùå Failed to update subnet description: {response.message}")
            raise typer.Exit(1)

    except Exception as e:
        print_error(f"‚ùå Failed to update subnet description: {str(e)}")
        raise typer.Exit(1)


@app.command()
def owner_transfer_ownership(
    subnet_id: int = typer.Option(..., "--subnet-id", "-s", help="Subnet ID"),
    new_owner: str = typer.Option(..., "--new-owner", "-o", help="New owner account address"),
    key_name: Optional[str] = typer.Option(
        None, "--key-name", "-k", help="Key name for signing (required for owner)"
    ),
    show_guidance: bool = typer.Option(
        True, "--guidance/--no-guidance", help="Show comprehensive guidance"
    ),
):
    """Transfer subnet ownership to another account (owner only)."""
    client = get_client()

    # Show comprehensive guidance
    if show_guidance:
        from rich.panel import Panel
        guidance_panel = Panel(
            f"[bold cyan]üëë Transfer Subnet Ownership Guide[/bold cyan]\n\n"
            f"This will transfer ownership of subnet {subnet_id} to {new_owner}:\n\n"
            f"[bold]What This Does:[/bold]\n"
            f"‚Ä¢ Initiates a two-step ownership transfer process\n"
            f"‚Ä¢ New owner must accept the transfer\n"
            f"‚Ä¢ You retain ownership until transfer is accepted\n"
            f"‚Ä¢ Can be undone before acceptance\n\n"
            f"[bold]Two-Step Process:[/bold]\n"
            f"1. You initiate transfer (this command)\n"
            f"2. New owner accepts transfer\n"
            f"3. Ownership officially transfers\n\n"
            f"[yellow]‚ö†Ô∏è Important:[/yellow]\n"
            f"‚Ä¢ This is a major operation\n"
            f"‚Ä¢ New owner will have full control\n"
            f"‚Ä¢ You can undo before acceptance\n"
            f"‚Ä¢ Verify the new owner address carefully",
            title="[bold red]üëë Transfer Subnet Ownership[/bold red]",
            border_style="red"
        )
        console.print(guidance_panel)
        console.print()

        # Ask for confirmation
        if not typer.confirm(f"Transfer ownership of subnet {subnet_id} to {new_owner}?"):
            print_info("Subnet ownership transfer cancelled.")
            return

    # Validate inputs
    if not validate_subnet_id(subnet_id):
        print_error("‚ùå Invalid subnet ID. Must be a positive integer.")
        raise typer.Exit(1)

    if not validate_address(new_owner):
        print_error("‚ùå Invalid new owner address.")
        raise typer.Exit(1)

    # Check if key_name is provided (required for owner operations)
    if not key_name:
        print_error("‚ùå Key name is required for subnet owner operations. Use --key-name to specify your signing key.")
        raise typer.Exit(1)

    try:
        # Check ownership (user must be the owner to transfer)
        subnet_response = client.get_subnet_data(subnet_id)
        if not subnet_response.success:
            print_error(f"‚ùå Failed to get subnet information: {subnet_response.message}")
            raise typer.Exit(1)

        subnet_info = subnet_response.data

        # Check if subnet exists
        if not subnet_info.get('exists', False):
            print_error(f"‚ùå Subnet {subnet_id} does not exist.")
            raise typer.Exit(1)

        # Check ownership (user must be the owner to transfer)
        from ..utils.ownership import get_user_addresses, user_owns_subnet
        user_addresses = get_user_addresses()
        if not user_owns_subnet(subnet_info, user_addresses):
            print_error(f"‚ùå You are not the owner of subnet {subnet_id}. Only the owner can transfer ownership.")
            raise typer.Exit(1)

        print_info(f"üëë Initiating ownership transfer of subnet {subnet_id} to {new_owner}...")

        response = client.transfer_subnet_ownership(subnet_id, new_owner, key_name=key_name)

        if response.success:
            print_success(f"‚úÖ Ownership transfer initiated for subnet {subnet_id}!")
            console.print(f"üìÑ Transaction Hash: [bold cyan]{response.transaction_hash}[/bold cyan]")
            if response.block_number:
                console.print(f"üì¶ Block Number: [bold cyan]#{response.block_number}[/bold cyan]")

            console.print(Panel(
                f"[bold yellow]üëë Ownership Transfer Initiated![/bold yellow]\n\n"
                f"Subnet {subnet_id} ownership transfer to {new_owner}:\n"
                f"‚Ä¢ Transfer initiated successfully\n"
                f"‚Ä¢ New owner must accept the transfer\n"
                f"‚Ä¢ You retain ownership until acceptance\n"
                f"‚Ä¢ Can be undone before acceptance\n\n"
                f"[yellow]üìã Next Steps:[/yellow]\n"
                f"‚Ä¢ New owner runs: [bold]htcli subnet owner-accept-ownership --subnet-id {subnet_id}[/bold]\n"
                f"‚Ä¢ To undo: [bold]htcli subnet owner-undo-transfer --subnet-id {subnet_id}[/bold]\n"
                f"‚Ä¢ Monitor: [bold]htcli subnet info --subnet-id {subnet_id}[/bold]",
                title="Transfer Initiated",
                border_style="yellow"
            ))
        else:
            print_error(f"‚ùå Failed to initiate ownership transfer: {response.message}")
            raise typer.Exit(1)

    except Exception as e:
        print_error(f"‚ùå Failed to initiate ownership transfer: {str(e)}")
        raise typer.Exit(1)


@app.command()
def owner_accept_ownership(
    subnet_id: int = typer.Option(..., "--subnet-id", "-s", help="Subnet ID"),
    key_name: Optional[str] = typer.Option(
        None, "--key-name", "-k", help="Key name for signing (required for new owner)"
    ),
    show_guidance: bool = typer.Option(
        True, "--guidance/--no-guidance", help="Show comprehensive guidance"
    ),
):
    """Accept subnet ownership transfer (new owner only)."""
    client = get_client()

    # Show comprehensive guidance
    if show_guidance:
        from rich.panel import Panel
        guidance_panel = Panel(
            f"[bold cyan]üëë Accept Subnet Ownership Guide[/bold cyan]\n\n"
            f"This will accept ownership of subnet {subnet_id}:\n\n"
            f"[bold]What This Does:[/bold]\n"
            f"‚Ä¢ Accepts a pending ownership transfer\n"
            f"‚Ä¢ Makes you the official subnet owner\n"
            f"‚Ä¢ Gives you full control over the subnet\n"
            f"‚Ä¢ Entitles you to 24% of subnet emissions\n\n"
            f"[bold]Requirements:[/bold]\n"
            f"‚Ä¢ You must be the designated new owner\n"
            f"‚Ä¢ Transfer must be pending (not accepted yet)\n"
            f"‚Ä¢ Valid signing key required\n\n"
            f"[yellow]‚ö†Ô∏è Important:[/yellow]\n"
            f"‚Ä¢ This is irreversible once accepted\n"
            f"‚Ä¢ You become responsible for the subnet\n"
            f"‚Ä¢ You gain 24% of subnet emissions\n"
            f"‚Ä¢ Previous owner loses all control",
            title="[bold green]üëë Accept Subnet Ownership[/bold green]",
            border_style="green"
        )
        console.print(guidance_panel)
        console.print()

        # Ask for confirmation
        if not typer.confirm(f"Accept ownership of subnet {subnet_id}?"):
            print_info("Subnet ownership acceptance cancelled.")
            return

    # Check if key_name is provided (required for owner operations)
    if not key_name:
        print_error("‚ùå Key name is required for subnet ownership operations. Use --key-name to specify your signing key.")
        raise typer.Exit(1)

    try:
        print_info(f"üëë Accepting ownership of subnet {subnet_id}...")

        response = client.accept_subnet_ownership(subnet_id, key_name=key_name)

        if response.success:
            print_success(f"‚úÖ Successfully accepted ownership of subnet {subnet_id}!")
            console.print(f"üìÑ Transaction Hash: [bold cyan]{response.transaction_hash}[/bold cyan]")
            if response.block_number:
                console.print(f"üì¶ Block Number: [bold cyan]#{response.block_number}[/bold cyan]")

            console.print(Panel(
                f"[bold green]üëë Ownership Accepted![/bold green]\n\n"
                f"You are now the owner of subnet {subnet_id}.\n"
                f"‚Ä¢ Full control over subnet operations\n"
                f"‚Ä¢ 24% of subnet emissions\n"
                f"‚Ä¢ All owner privileges activated\n"
                f"‚Ä¢ Previous owner no longer has control\n\n"
                f"[yellow]üéØ Your New Capabilities:[/yellow]\n"
                f"‚Ä¢ Activate/pause subnet\n"
                f"‚Ä¢ Update subnet information\n"
                f"‚Ä¢ Manage nodes and policies\n"
                f"‚Ä¢ Transfer ownership to others\n\n"
                f"[yellow]üìä Monitor Your Subnet:[/yellow]\n"
                f"Use: [bold]htcli subnet info --subnet-id {subnet_id}[/bold]",
                title="Ownership Transfer Complete",
                border_style="green"
            ))
        else:
            print_error(f"‚ùå Failed to accept ownership: {response.message}")
            raise typer.Exit(1)

    except Exception as e:
        print_error(f"‚ùå Failed to accept ownership: {str(e)}")
        raise typer.Exit(1)


@app.command()
def owner_undo_transfer(
    subnet_id: int = typer.Option(..., "--subnet-id", "-s", help="Subnet ID"),
    key_name: Optional[str] = typer.Option(
        None, "--key-name", "-k", help="Key name for signing (required for current owner)"
    ),
    show_guidance: bool = typer.Option(
        True, "--guidance/--no-guidance", help="Show comprehensive guidance"
    ),
):
    """Undo a pending ownership transfer (current owner only)."""
    client = get_client()

    # Show comprehensive guidance
    if show_guidance:
        from rich.panel import Panel
        guidance_panel = Panel(
            f"[bold cyan]üîÑ Undo Ownership Transfer Guide[/bold cyan]\n\n"
            f"This will undo the pending ownership transfer for subnet {subnet_id}:\n\n"
            f"[bold]What This Does:[/bold]\n"
            f"‚Ä¢ Cancels a pending ownership transfer\n"
            f"‚Ä¢ Keeps you as the subnet owner\n"
            f"‚Ä¢ Prevents the new owner from accepting\n"
            f"‚Ä¢ Maintains your current control\n\n"
            f"[bold]Requirements:[/bold]\n"
            f"‚Ä¢ You must be the current owner\n"
            f"‚Ä¢ Transfer must be pending (not accepted)\n"
            f"‚Ä¢ Valid signing key required\n\n"
            f"[yellow]‚ö†Ô∏è Important:[/yellow]\n"
            f"‚Ä¢ This cancels the transfer completely\n"
            f"‚Ä¢ New owner cannot accept after this\n"
            f"‚Ä¢ You retain full ownership\n"
            f"‚Ä¢ Can initiate new transfer if needed",
            title="[bold yellow]üîÑ Undo Ownership Transfer[/bold yellow]",
            border_style="yellow"
        )
        console.print(guidance_panel)
        console.print()

        # Ask for confirmation
        if not typer.confirm(f"Undo ownership transfer for subnet {subnet_id}?"):
            print_info("Ownership transfer undo cancelled.")
            return

    # Check if key_name is provided (required for owner operations)
    if not key_name:
        print_error("‚ùå Key name is required for subnet ownership operations. Use --key-name to specify your signing key.")
        raise typer.Exit(1)

    try:
        print_info(f"üîÑ Undoing ownership transfer for subnet {subnet_id}...")

        response = client.undo_subnet_ownership_transfer(subnet_id, key_name=key_name)

        if response.success:
            print_success(f"‚úÖ Successfully undone ownership transfer for subnet {subnet_id}!")
            console.print(f"üìÑ Transaction Hash: [bold cyan]{response.transaction_hash}[/bold cyan]")
            if response.block_number:
                console.print(f"üì¶ Block Number: [bold cyan]#{response.block_number}[/bold cyan]")

            console.print(Panel(
                f"[bold yellow]üîÑ Transfer Undone![/bold yellow]\n\n"
                f"Ownership transfer for subnet {subnet_id} has been cancelled.\n"
                f"‚Ä¢ You remain the subnet owner\n"
                f"‚Ä¢ Transfer is completely cancelled\n"
                f"‚Ä¢ New owner cannot accept\n"
                f"‚Ä¢ Full control maintained\n\n"
                f"[yellow]üìä Verify Status:[/yellow]\n"
                f"Use: [bold]htcli subnet info --subnet-id {subnet_id}[/bold]",
                title="Transfer Undone",
                border_style="yellow"
            ))
        else:
            print_error(f"‚ùå Failed to undo ownership transfer: {response.message}")
            raise typer.Exit(1)

    except Exception as e:
        print_error(f"‚ùå Failed to undo ownership transfer: {str(e)}")
        raise typer.Exit(1)


@app.command()
def owner_remove_node(
    subnet_id: int = typer.Option(..., "--subnet-id", "-s", help="Subnet ID"),
    node_id: int = typer.Option(..., "--node-id", "-n", help="Node ID to remove"),
    key_name: Optional[str] = typer.Option(
        None, "--key-name", "-k", help="Key name for signing (required for owner)"
    ),
    show_guidance: bool = typer.Option(
        True, "--guidance/--no-guidance", help="Show comprehensive guidance"
    ),
):
    """Remove a subnet node (owner only)."""
    client = get_client()

    # Show comprehensive guidance
    if show_guidance:
        from rich.panel import Panel
        guidance_panel = Panel(
            f"[bold cyan]üóëÔ∏è Remove Subnet Node Guide[/bold cyan]\n\n"
            f"This will remove node {node_id} from subnet {subnet_id}:\n\n"
            f"[bold]What This Does:[/bold]\n"
            f"‚Ä¢ Removes the node from the subnet\n"
            f"‚Ä¢ Node loses validator status\n"
            f"‚Ä¢ Node stops earning rewards\n"
            f"‚Ä¢ Subnet capacity reduced\n\n"
            f"[bold]Requirements:[/bold]\n"
            f"‚Ä¢ You must be the subnet owner\n"
            f"‚Ä¢ Node must exist in the subnet\n"
            f"‚Ä¢ Valid signing key required\n\n"
            f"[yellow]‚ö†Ô∏è Important:[/yellow]\n"
            f"‚Ä¢ This affects subnet performance\n"
            f"‚Ä¢ Node operator loses income\n"
            f"‚Ä¢ Consider impact on consensus\n"
            f"‚Ä¢ Ensure minimum node requirements",
            title="[bold red]üóëÔ∏è Remove Subnet Node[/bold red]",
            border_style="red"
        )
        console.print(guidance_panel)
        console.print()

        # Ask for confirmation
        if not typer.confirm(f"Remove node {node_id} from subnet {subnet_id}?"):
            print_info("Node removal cancelled.")
            return

    # Validate inputs
    if not validate_subnet_id(subnet_id):
        print_error("‚ùå Invalid subnet ID. Must be a positive integer.")
        raise typer.Exit(1)

    if not validate_node_id(node_id):
        print_error("‚ùå Invalid node ID. Must be a positive integer.")
        raise typer.Exit(1)

    # Check if key_name is provided (required for owner operations)
    if not key_name:
        print_error("‚ùå Key name is required for subnet owner operations. Use --key-name to specify your signing key.")
        raise typer.Exit(1)

    try:
        # Check ownership (user must be the owner to remove nodes)
        subnet_response = client.get_subnet_data(subnet_id)
        if not subnet_response.success:
            print_error(f"‚ùå Failed to get subnet information: {subnet_response.message}")
            raise typer.Exit(1)

        subnet_info = subnet_response.data

        # Check if subnet exists
        if not subnet_info.get('exists', False):
            print_error(f"‚ùå Subnet {subnet_id} does not exist.")
            raise typer.Exit(1)

        # Check ownership (user must be the owner to remove nodes)
        from ..utils.ownership import get_user_addresses, user_owns_subnet
        user_addresses = get_user_addresses()
        if not user_owns_subnet(subnet_info, user_addresses):
            print_error(f"‚ùå You are not the owner of subnet {subnet_id}. Only the owner can remove nodes.")
            raise typer.Exit(1)

        print_info(f"üóëÔ∏è Removing node {node_id} from subnet {subnet_id}...")

        response = client.owner_remove_subnet_node(subnet_id, node_id, key_name=key_name)

        if response.success:
            print_success(f"‚úÖ Successfully removed node {node_id} from subnet {subnet_id}!")
            console.print(f"üìÑ Transaction Hash: [bold cyan]{response.transaction_hash}[/bold cyan]")
            if response.block_number:
                console.print(f"üì¶ Block Number: [bold cyan]#{response.block_number}[/bold cyan]")

            console.print(Panel(
                f"[bold red]üóëÔ∏è Node Removed![/bold red]\n\n"
                f"Node {node_id} has been removed from subnet {subnet_id}.\n"
                f"‚Ä¢ Node is no longer a validator\n"
                f"‚Ä¢ Node stops earning rewards\n"
                f"‚Ä¢ Subnet capacity reduced\n"
                f"‚Ä¢ Node operator notified\n\n"
                f"[yellow]üìä Monitor Impact:[/yellow]\n"
                f"‚Ä¢ Check subnet performance\n"
                f"‚Ä¢ Monitor consensus stability\n"
                f"‚Ä¢ Consider adding new nodes\n\n"
                f"Use: [bold]htcli subnet info --subnet-id {subnet_id}[/bold]",
                title="Node Removal Complete",
                border_style="red"
            ))
        else:
            print_error(f"‚ùå Failed to remove node: {response.message}")
            raise typer.Exit(1)

    except Exception as e:
        print_error(f"‚ùå Failed to remove node: {str(e)}")
        raise typer.Exit(1)


@app.command()
def owner_update_churn_limit(
    subnet_id: int = typer.Option(..., "--subnet-id", "-s", help="Subnet ID"),
    churn_limit: int = typer.Option(..., "--churn-limit", "-c", help="New churn limit"),
    key_name: Optional[str] = typer.Option(
        None, "--key-name", "-k", help="Key name for signing (required for owner)"
    ),
    show_guidance: bool = typer.Option(
        True, "--guidance/--no-guidance", help="Show comprehensive guidance"
    ),
):
    """Update the churn limit for a subnet (owner only)."""
    client = get_client()

    # Show comprehensive guidance
    if show_guidance:
        from rich.panel import Panel
        guidance_panel = Panel(
            f"[bold cyan]‚öôÔ∏è Update Churn Limit Guide[/bold cyan]\n\n"
            f"This will update the churn limit for subnet {subnet_id} to {churn_limit}:\n\n"
            f"[bold]What is Churn Limit:[/bold]\n"
            f"‚Ä¢ Number of nodes that can activate per epoch\n"
            f"‚Ä¢ Controls how quickly nodes join the subnet\n"
            f"‚Ä¢ Affects node activation timing\n"
            f"‚Ä¢ Balances growth with stability\n\n"
            f"[bold]Impact:[/bold]\n"
            f"‚Ä¢ Higher limit = faster node onboarding\n"
            f"‚Ä¢ Lower limit = more controlled growth\n"
            f"‚Ä¢ Affects queue processing speed\n"
            f"‚Ä¢ Influences subnet expansion rate\n\n"
            f"[yellow]‚ö†Ô∏è Important:[/yellow]\n"
            f"‚Ä¢ Consider current queue size\n"
            f"‚Ä¢ Balance growth with stability\n"
            f"‚Ä¢ Monitor activation patterns\n"
            f"‚Ä¢ Ensure adequate capacity",
            title="[bold blue]‚öôÔ∏è Update Churn Limit[/bold blue]",
            border_style="blue"
        )
        console.print(guidance_panel)
        console.print()

        # Ask for confirmation
        if not typer.confirm(f"Update churn limit for subnet {subnet_id} to {churn_limit}?"):
            print_info("Churn limit update cancelled.")
            return

    # Validate inputs
    if not validate_subnet_id(subnet_id):
        print_error("‚ùå Invalid subnet ID. Must be a positive integer.")
        raise typer.Exit(1)

    if not validate_churn_limit(churn_limit):
        print_error("‚ùå Invalid churn limit. Must be a positive integer.")
        raise typer.Exit(1)

    # Check if key_name is provided (required for owner operations)
    if not key_name:
        print_error("‚ùå Key name is required for subnet owner operations. Use --key-name to specify your signing key.")
        raise typer.Exit(1)

    try:
        # Check ownership (user must be the owner to update parameters)
        subnet_response = client.get_subnet_data(subnet_id)
        if not subnet_response.success:
            print_error(f"‚ùå Failed to get subnet information: {subnet_response.message}")
            raise typer.Exit(1)

        subnet_info = subnet_response.data

        # Check if subnet exists
        if not subnet_info.get('exists', False):
            print_error(f"‚ùå Subnet {subnet_id} does not exist.")
            raise typer.Exit(1)

        # Check ownership (user must be the owner to update parameters)
        from ..utils.ownership import get_user_addresses, user_owns_subnet
        user_addresses = get_user_addresses()
        if not user_owns_subnet(subnet_info, user_addresses):
            print_error(f"‚ùå You are not the owner of subnet {subnet_id}. Only the owner can update parameters.")
            raise typer.Exit(1)

        print_info(f"‚öôÔ∏è Updating churn limit for subnet {subnet_id} to {churn_limit}...")

        response = client.owner_update_churn_limit(subnet_id, churn_limit, key_name=key_name)

        if response.success:
            print_success(f"‚úÖ Successfully updated churn limit for subnet {subnet_id} to {churn_limit}!")
            console.print(f"üìÑ Transaction Hash: [bold cyan]{response.transaction_hash}[/bold cyan]")
            if response.block_number:
                console.print(f"üì¶ Block Number: [bold cyan]#{response.block_number}[/bold cyan]")

            console.print(Panel(
                f"[bold green]‚öôÔ∏è Churn Limit Updated![/bold green]\n\n"
                f"Subnet {subnet_id} churn limit is now {churn_limit}.\n"
                f"‚Ä¢ {churn_limit} nodes can activate per epoch\n"
                f"‚Ä¢ Queue processing speed adjusted\n"
                f"‚Ä¢ Node onboarding rate changed\n"
                f"‚Ä¢ Growth pattern modified\n\n"
                f"[yellow]üìä Monitor Impact:[/yellow]\n"
                f"‚Ä¢ Watch queue processing speed\n"
                f"‚Ä¢ Monitor node activation patterns\n"
                f"‚Ä¢ Check subnet growth rate\n\n"
                f"Use: [bold]htcli subnet info --subnet-id {subnet_id}[/bold]",
                title="Churn Limit Update Complete",
                border_style="green"
            ))
        else:
            print_error(f"‚ùå Failed to update churn limit: {response.message}")
            raise typer.Exit(1)

    except Exception as e:
        print_error(f"‚ùå Failed to update churn limit: {str(e)}")
        raise typer.Exit(1)


@app.command()
def owner_update_min_stake(
    subnet_id: int = typer.Option(..., "--subnet-id", "-s", help="Subnet ID"),
    min_stake: int = typer.Option(..., "--min-stake", "-m", help="New minimum stake amount"),
    key_name: Optional[str] = typer.Option(
        None, "--key-name", "-k", help="Key name for signing (required for owner)"
    ),
    show_guidance: bool = typer.Option(
        True, "--guidance/--no-guidance", help="Show comprehensive guidance"
    ),
):
    """Update the minimum stake requirement for a subnet (owner only)."""
    client = get_client()

    # Show comprehensive guidance
    if show_guidance:
        from rich.panel import Panel
        guidance_panel = Panel(
            f"[bold cyan]üí∞ Update Minimum Stake Guide[/bold cyan]\n\n"
            f"This will update the minimum stake for subnet {subnet_id} to {format_balance(min_stake)}:\n\n"
            f"[bold]What is Minimum Stake:[/bold]\n"
            f"‚Ä¢ Minimum balance required for nodes to register\n"
            f"‚Ä¢ Affects node registration requirements\n"
            f"‚Ä¢ Can force existing nodes to be removed\n"
            f"‚Ä¢ Balances are checked during operations\n\n"
            f"[bold]Impact:[/bold]\n"
            f"‚Ä¢ Higher minimum = more expensive to join\n"
            f"‚Ä¢ Lower minimum = easier to join\n"
            f"‚Ä¢ Existing nodes may be affected\n"
            f"‚Ä¢ Influences subnet quality\n\n"
            f"[yellow]‚ö†Ô∏è Important:[/yellow]\n"
            f"‚Ä¢ This can force nodes to be removed!\n"
            f"‚Ä¢ Consider impact on existing nodes\n"
            f"‚Ä¢ Balance is checked during:\n"
            f"  - Registering\n"
            f"  - Activating\n"
            f"  - Validating\n"
            f"  - Attesting",
            title="[bold red]üí∞ Update Minimum Stake[/bold red]",
            border_style="red"
        )
        console.print(guidance_panel)
        console.print()

        # Ask for confirmation
        if not typer.confirm(f"Update minimum stake for subnet {subnet_id} to {format_balance(min_stake)}?"):
            print_info("Minimum stake update cancelled.")
            return

    # Validate inputs
    if not validate_subnet_id(subnet_id):
        print_error("‚ùå Invalid subnet ID. Must be a positive integer.")
        raise typer.Exit(1)

    if not validate_stake_amount(min_stake):
        print_error("‚ùå Invalid minimum stake amount.")
        raise typer.Exit(1)

    # Check if key_name is provided (required for owner operations)
    if not key_name:
        print_error("‚ùå Key name is required for subnet owner operations. Use --key-name to specify your signing key.")
        raise typer.Exit(1)

    try:
        # Check ownership (user must be the owner to update parameters)
        subnet_response = client.get_subnet_data(subnet_id)
        if not subnet_response.success:
            print_error(f"‚ùå Failed to get subnet information: {subnet_response.message}")
            raise typer.Exit(1)

        subnet_info = subnet_response.data

        # Check if subnet exists
        if not subnet_info.get('exists', False):
            print_error(f"‚ùå Subnet {subnet_id} does not exist.")
            raise typer.Exit(1)

        # Check ownership (user must be the owner to update parameters)
        from ..utils.ownership import get_user_addresses, user_owns_subnet
        user_addresses = get_user_addresses()
        if not user_owns_subnet(subnet_info, user_addresses):
            print_error(f"‚ùå You are not the owner of subnet {subnet_id}. Only the owner can update parameters.")
            raise typer.Exit(1)

        print_info(f"üí∞ Updating minimum stake for subnet {subnet_id} to {format_balance(min_stake)}...")

        response = client.owner_update_min_stake(subnet_id, min_stake, key_name=key_name)

        if response.success:
            print_success(f"‚úÖ Successfully updated minimum stake for subnet {subnet_id} to {format_balance(min_stake)}!")
            console.print(f"üìÑ Transaction Hash: [bold cyan]{response.transaction_hash}[/bold cyan]")
            if response.block_number:
                console.print(f"üì¶ Block Number: [bold cyan]#{response.block_number}[/bold cyan]")

            console.print(Panel(
                f"[bold green]üí∞ Minimum Stake Updated![/bold green]\n\n"
                f"Subnet {subnet_id} minimum stake is now {format_balance(min_stake)}.\n"
                f"‚Ä¢ New nodes must meet this requirement\n"
                f"‚Ä¢ Existing nodes may be affected\n"
                f"‚Ä¢ Registration requirements changed\n"
                f"‚Ä¢ Quality threshold adjusted\n\n"
                f"[yellow]üìä Monitor Impact:[/yellow]\n"
                f"‚Ä¢ Check if existing nodes are affected\n"
                f"‚Ä¢ Monitor node registration patterns\n"
                f"‚Ä¢ Watch subnet quality changes\n\n"
                f"Use: [bold]htcli subnet info --subnet-id {subnet_id}[/bold]",
                title="Minimum Stake Update Complete",
                border_style="green"
            ))
        else:
            print_error(f"‚ùå Failed to update minimum stake: {response.message}")
            raise typer.Exit(1)

    except Exception as e:
        print_error(f"‚ùå Failed to update minimum stake: {str(e)}")
        raise typer.Exit(1)


@app.command()
def owner_update_max_stake(
    subnet_id: int = typer.Option(..., "--subnet-id", "-s", help="Subnet ID"),
    max_stake: int = typer.Option(..., "--max-stake", "-m", help="New maximum stake amount"),
    key_name: Optional[str] = typer.Option(
        None, "--key-name", "-k", help="Key name for signing (required for owner)"
    ),
    show_guidance: bool = typer.Option(
        True, "--guidance/--no-guidance", help="Show comprehensive guidance"
    ),
):
    """Update the maximum stake limit for a subnet (owner only)."""
    client = get_client()

    # Show comprehensive guidance
    if show_guidance:
        from rich.panel import Panel
        guidance_panel = Panel(
            f"[bold cyan]üí∞ Update Maximum Stake Guide[/bold cyan]\n\n"
            f"This will update the maximum stake for subnet {subnet_id} to {format_balance(max_stake)}:\n\n"
            f"[bold]What is Maximum Stake:[/bold]\n"
            f"‚Ä¢ Maximum balance for subnet nodes to register\n"
            f"‚Ä¢ Nodes cannot register or increase stake past this value\n"
            f"‚Ä¢ Balances can be higher than this threshold\n"
            f"‚Ä¢ Controls node capacity limits\n\n"
            f"[bold]Impact:[/bold]\n"
            f"‚Ä¢ Higher maximum = more node capacity\n"
            f"‚Ä¢ Lower maximum = restricted growth\n"
            f"‚Ä¢ Affects node registration limits\n"
            f"‚Ä¢ Influences subnet scalability\n\n"
            f"[yellow]‚ö†Ô∏è Important:[/yellow]\n"
            f"‚Ä¢ This affects node registration limits\n"
            f"‚Ä¢ Consider current and future growth\n"
            f"‚Ä¢ Balance scalability with stability\n"
            f"‚Ä¢ Monitor registration patterns",
            title="[bold blue]üí∞ Update Maximum Stake[/bold blue]",
            border_style="blue"
        )
        console.print(guidance_panel)
        console.print()

        # Ask for confirmation
        if not typer.confirm(f"Update maximum stake for subnet {subnet_id} to {format_balance(max_stake)}?"):
            print_info("Maximum stake update cancelled.")
            return

    # Validate inputs
    if not validate_subnet_id(subnet_id):
        print_error("‚ùå Invalid subnet ID. Must be a positive integer.")
        raise typer.Exit(1)

    if not validate_stake_amount(max_stake):
        print_error("‚ùå Invalid maximum stake amount.")
        raise typer.Exit(1)

    # Check if key_name is provided (required for owner operations)
    if not key_name:
        print_error("‚ùå Key name is required for subnet owner operations. Use --key-name to specify your signing key.")
        raise typer.Exit(1)

    try:
        # Check ownership (user must be the owner to update parameters)
        subnet_response = client.get_subnet_data(subnet_id)
        if not subnet_response.success:
            print_error(f"‚ùå Failed to get subnet information: {subnet_response.message}")
            raise typer.Exit(1)

        subnet_info = subnet_response.data

        # Check if subnet exists
        if not subnet_info.get('exists', False):
            print_error(f"‚ùå Subnet {subnet_id} does not exist.")
            raise typer.Exit(1)

        # Check ownership (user must be the owner to update parameters)
        from ..utils.ownership import get_user_addresses, user_owns_subnet
        user_addresses = get_user_addresses()
        if not user_owns_subnet(subnet_info, user_addresses):
            print_error(f"‚ùå You are not the owner of subnet {subnet_id}. Only the owner can update parameters.")
            raise typer.Exit(1)

        print_info(f"üí∞ Updating maximum stake for subnet {subnet_id} to {format_balance(max_stake)}...")

        response = client.owner_update_max_stake(subnet_id, max_stake, key_name=key_name)

        if response.success:
            print_success(f"‚úÖ Successfully updated maximum stake for subnet {subnet_id} to {format_balance(max_stake)}!")
            console.print(f"üìÑ Transaction Hash: [bold cyan]{response.transaction_hash}[/bold cyan]")
            if response.block_number:
                console.print(f"üì¶ Block Number: [bold cyan]#{response.block_number}[/bold cyan]")

            console.print(Panel(
                f"[bold green]üí∞ Maximum Stake Updated![/bold green]\n\n"
                f"Subnet {subnet_id} maximum stake is now {format_balance(max_stake)}.\n"
                f"‚Ä¢ Node registration limit adjusted\n"
                f"‚Ä¢ Growth capacity modified\n"
                f"‚Ä¢ Scalability parameters changed\n"
                f"‚Ä¢ Registration requirements updated\n\n"
                f"[yellow]üìä Monitor Impact:[/yellow]\n"
                f"‚Ä¢ Watch node registration patterns\n"
                f"‚Ä¢ Monitor growth capacity\n"
                f"‚Ä¢ Check scalability metrics\n\n"
                f"Use: [bold]htcli subnet info --subnet-id {subnet_id}[/bold]",
                title="Maximum Stake Update Complete",
                border_style="green"
            ))
        else:
            print_error(f"‚ùå Failed to update maximum stake: {response.message}")
            raise typer.Exit(1)

    except Exception as e:
        print_error(f"‚ùå Failed to update maximum stake: {str(e)}")
        raise typer.Exit(1)


@app.command()
def owner_update_registration_epochs(
    subnet_id: int = typer.Option(..., "--subnet-id", "-s", help="Subnet ID"),
    epochs: int = typer.Option(..., "--epochs", "-e", help="New registration queue epochs"),
    key_name: Optional[str] = typer.Option(
        None, "--key-name", "-k", help="Key name for signing (required for owner)"
    ),
    show_guidance: bool = typer.Option(
        True, "--guidance/--no-guidance", help="Show comprehensive guidance"
    ),
):
    """Update registration queue epochs for a subnet (owner only)."""
    client = get_client()

    # Show comprehensive guidance
    if show_guidance:
        from rich.panel import Panel
        guidance_panel = Panel(
            f"[bold cyan]‚è±Ô∏è Update Registration Queue Epochs Guide[/bold cyan]\n\n"
            f"This will update the registration queue epochs for subnet {subnet_id} to {epochs}:\n\n"
            f"[bold]What are Registration Queue Epochs:[/bold]\n"
            f"‚Ä¢ Number of epochs nodes must wait in queue before activation\n"
            f"‚Ä¢ Controls how long nodes wait before becoming active\n"
            f"‚Ä¢ Works with churn limit to calculate start epochs\n"
            f"‚Ä¢ Affects node onboarding timing\n\n"
            f"[bold]Impact:[/bold]\n"
            f"‚Ä¢ Higher epochs = longer wait time\n"
            f"‚Ä¢ Lower epochs = faster activation\n"
            f"‚Ä¢ Affects queue processing speed\n"
            f"‚Ä¢ Influences subnet growth rate\n\n"
            f"[yellow]‚ö†Ô∏è Important:[/yellow]\n"
            f"‚Ä¢ Consider current queue size\n"
            f"‚Ä¢ Balance speed with stability\n"
            f"‚Ä¢ Monitor activation patterns\n"
            f"‚Ä¢ Works with churn limit",
            title="[bold blue]‚è±Ô∏è Update Registration Queue Epochs[/bold blue]",
            border_style="blue"
        )
        console.print(guidance_panel)
        console.print()

        # Ask for confirmation
        if not typer.confirm(f"Update registration queue epochs for subnet {subnet_id} to {epochs}?"):
            print_info("Registration queue epochs update cancelled.")
            return

    # Validate inputs
    if not validate_subnet_id(subnet_id):
        print_error("‚ùå Invalid subnet ID. Must be a positive integer.")
        raise typer.Exit(1)

    if not validate_epoch_value(epochs):
        print_error("‚ùå Invalid epoch value. Must be a positive integer.")
        raise typer.Exit(1)

    # Check if key_name is provided (required for owner operations)
    if not key_name:
        print_error("‚ùå Key name is required for subnet owner operations. Use --key-name to specify your signing key.")
        raise typer.Exit(1)

    try:
        # Check ownership (user must be the owner to update parameters)
        subnet_response = client.get_subnet_data(subnet_id)
        if not subnet_response.success:
            print_error(f"‚ùå Failed to get subnet information: {subnet_response.message}")
            raise typer.Exit(1)

        subnet_info = subnet_response.data

        # Check if subnet exists
        if not subnet_info.get('exists', False):
            print_error(f"‚ùå Subnet {subnet_id} does not exist.")
            raise typer.Exit(1)

        # Check ownership (user must be the owner to update parameters)
        from ..utils.ownership import get_user_addresses, user_owns_subnet
        user_addresses = get_user_addresses()
        if not user_owns_subnet(subnet_info, user_addresses):
            print_error(f"‚ùå You are not the owner of subnet {subnet_id}. Only the owner can update parameters.")
            raise typer.Exit(1)

        print_info(f"‚è±Ô∏è Updating registration queue epochs for subnet {subnet_id} to {epochs}...")

        response = client.owner_update_registration_epochs(subnet_id, epochs, key_name=key_name)

        if response.success:
            print_success(f"‚úÖ Successfully updated registration queue epochs for subnet {subnet_id} to {epochs}!")
            console.print(f"üìÑ Transaction Hash: [bold cyan]{response.transaction_hash}[/bold cyan]")
            if response.block_number:
                console.print(f"üì¶ Block Number: [bold cyan]#{response.block_number}[/bold cyan]")

            console.print(Panel(
                f"[bold green]‚è±Ô∏è Registration Queue Epochs Updated![/bold green]\n\n"
                f"Subnet {subnet_id} registration queue epochs is now {epochs}.\n"
                f"‚Ä¢ Nodes wait {epochs} epochs before activation\n"
                f"‚Ä¢ Queue processing timing adjusted\n"
                f"‚Ä¢ Node onboarding rate modified\n"
                f"‚Ä¢ Growth pattern changed\n\n"
                f"[yellow]üìä Monitor Impact:[/yellow]\n"
                f"‚Ä¢ Watch queue processing speed\n"
                f"‚Ä¢ Monitor node activation timing\n"
                f"‚Ä¢ Check growth patterns\n\n"
                f"Use: [bold]htcli subnet info --subnet-id {subnet_id}[/bold]",
                title="Registration Epochs Update Complete",
                border_style="green"
            ))
        else:
            print_error(f"‚ùå Failed to update registration queue epochs: {response.message}")
            raise typer.Exit(1)

    except Exception as e:
        print_error(f"‚ùå Failed to update registration queue epochs: {str(e)}")
        raise typer.Exit(1)


@app.command()
def owner_update_activation_grace_epochs(
    subnet_id: int = typer.Option(..., "--subnet-id", "-s", help="Subnet ID"),
    epochs: int = typer.Option(..., "--epochs", "-e", help="New activation grace epochs"),
    key_name: Optional[str] = typer.Option(
        None, "--key-name", "-k", help="Key name for signing (required for owner)"
    ),
    show_guidance: bool = typer.Option(
        True, "--guidance/--no-guidance", help="Show comprehensive guidance"
    ),
):
    """Update activation grace epochs for a subnet (owner only)."""
    client = get_client()

    # Show comprehensive guidance
    if show_guidance:
        from rich.panel import Panel
        guidance_panel = Panel(
            f"[bold cyan]‚è±Ô∏è Update Activation Grace Epochs Guide[/bold cyan]\n\n"
            f"This will update the activation grace epochs for subnet {subnet_id} to {epochs}:\n\n"
            f"[bold]What are Activation Grace Epochs:[/bold]\n"
            f"‚Ä¢ Grace period for nodes to activate from their start epoch\n"
            f"‚Ä¢ Allows flexibility in activation timing\n"
            f"‚Ä¢ Extends activation window beyond start epoch\n"
            f"‚Ä¢ Provides buffer for node operators\n\n"
            f"[bold]Impact:[/bold]\n"
            f"‚Ä¢ Higher epochs = more flexible activation\n"
            f"‚Ä¢ Lower epochs = stricter timing\n"
            f"‚Ä¢ Affects node activation success rate\n"
            f"‚Ä¢ Influences subnet reliability\n\n"
            f"[yellow]‚ö†Ô∏è Important:[/yellow]\n"
            f"‚Ä¢ Consider node operator needs\n"
            f"‚Ä¢ Balance flexibility with efficiency\n"
            f"‚Ä¢ Monitor activation success rates\n"
            f"‚Ä¢ Works with registration epochs",
            title="[bold blue]‚è±Ô∏è Update Activation Grace Epochs[/bold blue]",
            border_style="blue"
        )
        console.print(guidance_panel)
        console.print()

        # Ask for confirmation
        if not typer.confirm(f"Update activation grace epochs for subnet {subnet_id} to {epochs}?"):
            print_info("Activation grace epochs update cancelled.")
            return

    # Validate inputs
    if not validate_subnet_id(subnet_id):
        print_error("‚ùå Invalid subnet ID. Must be a positive integer.")
        raise typer.Exit(1)

    if not validate_epoch_value(epochs):
        print_error("‚ùå Invalid epoch value. Must be a positive integer.")
        raise typer.Exit(1)

    # Check if key_name is provided (required for owner operations)
    if not key_name:
        print_error("‚ùå Key name is required for subnet owner operations. Use --key-name to specify your signing key.")
        raise typer.Exit(1)

    try:
        # Check ownership (user must be the owner to update parameters)
        subnet_response = client.get_subnet_data(subnet_id)
        if not subnet_response.success:
            print_error(f"‚ùå Failed to get subnet information: {subnet_response.message}")
            raise typer.Exit(1)

        subnet_info = subnet_response.data

        # Check if subnet exists
        if not subnet_info.get('exists', False):
            print_error(f"‚ùå Subnet {subnet_id} does not exist.")
            raise typer.Exit(1)

        # Check ownership (user must be the owner to update parameters)
        from ..utils.ownership import get_user_addresses, user_owns_subnet
        user_addresses = get_user_addresses()
        if not user_owns_subnet(subnet_info, user_addresses):
            print_error(f"‚ùå You are not the owner of subnet {subnet_id}. Only the owner can update parameters.")
            raise typer.Exit(1)

        print_info(f"‚è±Ô∏è Updating activation grace epochs for subnet {subnet_id} to {epochs}...")

        response = client.owner_update_activation_grace_epochs(subnet_id, epochs, key_name=key_name)

        if response.success:
            print_success(f"‚úÖ Successfully updated activation grace epochs for subnet {subnet_id} to {epochs}!")
            console.print(f"üìÑ Transaction Hash: [bold cyan]{response.transaction_hash}[/bold cyan]")
            if response.block_number:
                console.print(f"üì¶ Block Number: [bold cyan]#{response.block_number}[/bold cyan]")

            console.print(Panel(
                f"[bold green]‚è±Ô∏è Activation Grace Epochs Updated![/bold green]\n\n"
                f"Subnet {subnet_id} activation grace epochs is now {epochs}.\n"
                f"‚Ä¢ Nodes have {epochs} epochs grace period\n"
                f"‚Ä¢ More flexible activation timing\n"
                f"‚Ä¢ Better success rate for nodes\n"
                f"‚Ä¢ Improved subnet reliability\n\n"
                f"[yellow]üìä Monitor Impact:[/yellow]\n"
                f"‚Ä¢ Watch activation success rates\n"
                f"‚Ä¢ Monitor node onboarding\n"
                f"‚Ä¢ Check subnet stability\n\n"
                f"Use: [bold]htcli subnet info --subnet-id {subnet_id}[/bold]",
                title="Activation Grace Epochs Update Complete",
                border_style="green"
            ))
        else:
            print_error(f"‚ùå Failed to update activation grace epochs: {response.message}")
            raise typer.Exit(1)

    except Exception as e:
        print_error(f"‚ùå Failed to update activation grace epochs: {str(e)}")
        raise typer.Exit(1)


@app.command()
def owner_update_idle_epochs(
    subnet_id: int = typer.Option(..., "--subnet-id", "-s", help="Subnet ID"),
    epochs: int = typer.Option(..., "--epochs", "-e", help="New idle classification epochs"),
    key_name: Optional[str] = typer.Option(
        None, "--key-name", "-k", help="Key name for signing (required for owner)"
    ),
    show_guidance: bool = typer.Option(
        True, "--guidance/--no-guidance", help="Show comprehensive guidance"
    ),
):
    """Update idle classification epochs for a subnet (owner only)."""
    client = get_client()

    # Show comprehensive guidance
    if show_guidance:
        from rich.panel import Panel
        guidance_panel = Panel(
            f"[bold cyan]‚è±Ô∏è Update Idle Classification Epochs Guide[/bold cyan]\n\n"
            f"This will update the idle classification epochs for subnet {subnet_id} to {epochs}:\n\n"
            f"[bold]What are Idle Classification Epochs:[/bold]\n"
            f"‚Ä¢ Number of epochs nodes stay in idle classification\n"
            f"‚Ä¢ Period before upgrading to included classification\n"
            f"‚Ä¢ Affects node progression through classifications\n"
            f"‚Ä¢ Influences validator selection timing\n\n"
            f"[bold]Impact:[/bold]\n"
            f"‚Ä¢ Higher epochs = longer idle period\n"
            f"‚Ä¢ Lower epochs = faster progression\n"
            f"‚Ä¢ Affects validator selection\n"
            f"‚Ä¢ Influences subnet performance\n\n"
            f"[yellow]‚ö†Ô∏è Important:[/yellow]\n"
            f"‚Ä¢ Consider subnet performance needs\n"
            f"‚Ä¢ Balance progression with stability\n"
            f"‚Ä¢ Monitor validator selection\n"
            f"‚Ä¢ Works with other classification epochs",
            title="[bold blue]‚è±Ô∏è Update Idle Classification Epochs[/bold blue]",
            border_style="blue"
        )
        console.print(guidance_panel)
        console.print()

        # Ask for confirmation
        if not typer.confirm(f"Update idle classification epochs for subnet {subnet_id} to {epochs}?"):
            print_info("Idle classification epochs update cancelled.")
            return

    # Validate inputs
    if not validate_subnet_id(subnet_id):
        print_error("‚ùå Invalid subnet ID. Must be a positive integer.")
        raise typer.Exit(1)

    if not validate_epoch_value(epochs):
        print_error("‚ùå Invalid epoch value. Must be a positive integer.")
        raise typer.Exit(1)

    # Check if key_name is provided (required for owner operations)
    if not key_name:
        print_error("‚ùå Key name is required for subnet owner operations. Use --key-name to specify your signing key.")
        raise typer.Exit(1)

    try:
        # Check ownership (user must be the owner to update parameters)
        subnet_response = client.get_subnet_data(subnet_id)
        if not subnet_response.success:
            print_error(f"‚ùå Failed to get subnet information: {subnet_response.message}")
            raise typer.Exit(1)

        subnet_info = subnet_response.data

        # Check if subnet exists
        if not subnet_info.get('exists', False):
            print_error(f"‚ùå Subnet {subnet_id} does not exist.")
            raise typer.Exit(1)

        # Check ownership (user must be the owner to update parameters)
        from ..utils.ownership import get_user_addresses, user_owns_subnet
        user_addresses = get_user_addresses()
        if not user_owns_subnet(subnet_info, user_addresses):
            print_error(f"‚ùå You are not the owner of subnet {subnet_id}. Only the owner can update parameters.")
            raise typer.Exit(1)

        print_info(f"‚è±Ô∏è Updating idle classification epochs for subnet {subnet_id} to {epochs}...")

        response = client.owner_update_idle_epochs(subnet_id, epochs, key_name=key_name)

        if response.success:
            print_success(f"‚úÖ Successfully updated idle classification epochs for subnet {subnet_id} to {epochs}!")
            console.print(f"üìÑ Transaction Hash: [bold cyan]{response.transaction_hash}[/bold cyan]")
            if response.block_number:
                console.print(f"üì¶ Block Number: [bold cyan]#{response.block_number}[/bold cyan]")

            console.print(Panel(
                f"[bold green]‚è±Ô∏è Idle Classification Epochs Updated![/bold green]\n\n"
                f"Subnet {subnet_id} idle classification epochs is now {epochs}.\n"
                f"‚Ä¢ Nodes stay idle for {epochs} epochs\n"
                f"‚Ä¢ Progression timing adjusted\n"
                f"‚Ä¢ Validator selection affected\n"
                f"‚Ä¢ Performance parameters modified\n\n"
                f"[yellow]üìä Monitor Impact:[/yellow]\n"
                f"‚Ä¢ Watch node progression\n"
                f"‚Ä¢ Monitor validator selection\n"
                f"‚Ä¢ Check subnet performance\n\n"
                f"Use: [bold]htcli subnet info --subnet-id {subnet_id}[/bold]",
                title="Idle Epochs Update Complete",
                border_style="green"
            ))
        else:
            print_error(f"‚ùå Failed to update idle classification epochs: {response.message}")
            raise typer.Exit(1)

    except Exception as e:
        print_error(f"‚ùå Failed to update idle classification epochs: {str(e)}")
        raise typer.Exit(1)


@app.command()
def owner_update_included_epochs(
    subnet_id: int = typer.Option(..., "--subnet-id", "-s", help="Subnet ID"),
    epochs: int = typer.Option(..., "--epochs", "-e", help="New included classification epochs"),
    key_name: Optional[str] = typer.Option(
        None, "--key-name", "-k", help="Key name for signing (required for owner)"
    ),
    show_guidance: bool = typer.Option(
        True, "--guidance/--no-guidance", help="Show comprehensive guidance"
    ),
):
    """Update included classification epochs for a subnet (owner only)."""
    client = get_client()

    # Show comprehensive guidance
    if show_guidance:
        from rich.panel import Panel
        guidance_panel = Panel(
            f"[bold cyan]‚è±Ô∏è Update Included Classification Epochs Guide[/bold cyan]\n\n"
            f"This will update the included classification epochs for subnet {subnet_id} to {epochs}:\n\n"
            f"[bold]What are Included Classification Epochs:[/bold]\n"
            f"‚Ä¢ Number of epochs nodes stay in included classification\n"
            f"‚Ä¢ Period before upgrading to validator classification\n"
            f"‚Ä¢ Final stage before becoming active validators\n"
            f"‚Ä¢ Critical for validator selection\n\n"
            f"[bold]Impact:[/bold]\n"
            f"‚Ä¢ Higher epochs = longer included period\n"
            f"‚Ä¢ Lower epochs = faster validator promotion\n"
            f"‚Ä¢ Affects validator pool size\n"
            f"‚Ä¢ Influences consensus stability\n\n"
            f"[yellow]‚ö†Ô∏è Important:[/yellow]\n"
            f"‚Ä¢ Consider consensus stability needs\n"
            f"‚Ä¢ Balance promotion with quality\n"
            f"‚Ä¢ Monitor validator pool size\n"
            f"‚Ä¢ Critical for subnet performance",
            title="[bold blue]‚è±Ô∏è Update Included Classification Epochs[/bold blue]",
            border_style="blue"
        )
        console.print(guidance_panel)
        console.print()

        # Ask for confirmation
        if not typer.confirm(f"Update included classification epochs for subnet {subnet_id} to {epochs}?"):
            print_info("Included classification epochs update cancelled.")
            return

    # Validate inputs
    if not validate_subnet_id(subnet_id):
        print_error("‚ùå Invalid subnet ID. Must be a positive integer.")
        raise typer.Exit(1)

    if not validate_epoch_value(epochs):
        print_error("‚ùå Invalid epoch value. Must be a positive integer.")
        raise typer.Exit(1)

    # Check if key_name is provided (required for owner operations)
    if not key_name:
        print_error("‚ùå Key name is required for subnet owner operations. Use --key-name to specify your signing key.")
        raise typer.Exit(1)

    try:
        # Check ownership (user must be the owner to update parameters)
        subnet_response = client.get_subnet_data(subnet_id)
        if not subnet_response.success:
            print_error(f"‚ùå Failed to get subnet information: {subnet_response.message}")
            raise typer.Exit(1)

        subnet_info = subnet_response.data

        # Check if subnet exists
        if not subnet_info.get('exists', False):
            print_error(f"‚ùå Subnet {subnet_id} does not exist.")
            raise typer.Exit(1)

        # Check ownership (user must be the owner to update parameters)
        from ..utils.ownership import get_user_addresses, user_owns_subnet
        user_addresses = get_user_addresses()
        if not user_owns_subnet(subnet_info, user_addresses):
            print_error(f"‚ùå You are not the owner of subnet {subnet_id}. Only the owner can update parameters.")
            raise typer.Exit(1)

        print_info(f"‚è±Ô∏è Updating included classification epochs for subnet {subnet_id} to {epochs}...")

        response = client.owner_update_included_epochs(subnet_id, epochs, key_name=key_name)

        if response.success:
            print_success(f"‚úÖ Successfully updated included classification epochs for subnet {subnet_id} to {epochs}!")
            console.print(f"üìÑ Transaction Hash: [bold cyan]{response.transaction_hash}[/bold cyan]")
            if response.block_number:
                console.print(f"üì¶ Block Number: [bold cyan]#{response.block_number}[/bold cyan]")

            console.print(Panel(
                f"[bold green]‚è±Ô∏è Included Classification Epochs Updated![/bold green]\n\n"
                f"Subnet {subnet_id} included classification epochs is now {epochs}.\n"
                f"‚Ä¢ Nodes stay included for {epochs} epochs\n"
                f"‚Ä¢ Validator promotion timing adjusted\n"
                f"‚Ä¢ Validator pool size affected\n"
                f"‚Ä¢ Consensus stability modified\n\n"
                f"[yellow]üìä Monitor Impact:[/yellow]\n"
                f"‚Ä¢ Watch validator pool size\n"
                f"‚Ä¢ Monitor consensus stability\n"
                f"‚Ä¢ Check subnet performance\n\n"
                f"Use: [bold]htcli subnet info --subnet-id {subnet_id}[/bold]",
                title="Included Epochs Update Complete",
                border_style="green"
            ))
        else:
            print_error(f"‚ùå Failed to update included classification epochs: {response.message}")
            raise typer.Exit(1)

    except Exception as e:
        print_error(f"‚ùå Failed to update included classification epochs: {str(e)}")
        raise typer.Exit(1)


@app.command()
def owner_update_max_penalties(
    subnet_id: int = typer.Option(..., "--subnet-id", "-s", help="Subnet ID"),
    max_penalties: int = typer.Option(..., "--max-penalties", "-p", help="New maximum node penalties"),
    key_name: Optional[str] = typer.Option(
        None, "--key-name", "-k", help="Key name for signing (required for owner)"
    ),
    show_guidance: bool = typer.Option(
        True, "--guidance/--no-guidance", help="Show comprehensive guidance"
    ),
):
    """Update maximum node penalties for a subnet (owner only)."""
    client = get_client()

    # Show comprehensive guidance
    if show_guidance:
        from rich.panel import Panel
        guidance_panel = Panel(
            f"[bold cyan]‚ö†Ô∏è Update Maximum Node Penalties Guide[/bold cyan]\n\n"
            f"This will update the maximum node penalties for subnet {subnet_id} to {max_penalties}:\n\n"
            f"[bold]What are Maximum Node Penalties:[/bold]\n"
            f"‚Ä¢ Maximum number of penalties a validator node can have\n"
            f"‚Ä¢ Nodes are removed when they exceed this limit\n"
            f"‚Ä¢ Affects validator quality and reliability\n"
            f"‚Ä¢ Influences subnet performance standards\n\n"
            f"[bold]Impact:[/bold]\n"
            f"‚Ä¢ Higher limit = more tolerance for errors\n"
            f"‚Ä¢ Lower limit = stricter quality standards\n"
            f"‚Ä¢ Affects validator retention\n"
            f"‚Ä¢ Influences subnet reliability\n\n"
            f"[yellow]‚ö†Ô∏è Important:[/yellow]\n"
            f"‚Ä¢ This affects validator quality\n"
            f"‚Ä¢ Consider subnet performance needs\n"
            f"‚Ä¢ Monitor penalty patterns\n"
            f"‚Ä¢ Balance tolerance with quality",
            title="[bold red]‚ö†Ô∏è Update Maximum Node Penalties[/bold red]",
            border_style="red"
        )
        console.print(guidance_panel)
        console.print()

        # Ask for confirmation
        if not typer.confirm(f"Update maximum node penalties for subnet {subnet_id} to {max_penalties}?"):
            print_info("Maximum node penalties update cancelled.")
            return

    # Validate inputs
    if not validate_subnet_id(subnet_id):
        print_error("‚ùå Invalid subnet ID. Must be a positive integer.")
        raise typer.Exit(1)

    if not validate_max_penalties(max_penalties):
        print_error("‚ùå Invalid maximum penalties value. Must be a positive integer.")
        raise typer.Exit(1)

    # Check if key_name is provided (required for owner operations)
    if not key_name:
        print_error("‚ùå Key name is required for subnet owner operations. Use --key-name to specify your signing key.")
        raise typer.Exit(1)

    try:
        # Check ownership (user must be the owner to update parameters)
        subnet_response = client.get_subnet_data(subnet_id)
        if not subnet_response.success:
            print_error(f"‚ùå Failed to get subnet information: {subnet_response.message}")
            raise typer.Exit(1)

        subnet_info = subnet_response.data

        # Check if subnet exists
        if not subnet_info.get('exists', False):
            print_error(f"‚ùå Subnet {subnet_id} does not exist.")
            raise typer.Exit(1)

        # Check ownership (user must be the owner to update parameters)
        from ..utils.ownership import get_user_addresses, user_owns_subnet
        user_addresses = get_user_addresses()
        if not user_owns_subnet(subnet_info, user_addresses):
            print_error(f"‚ùå You are not the owner of subnet {subnet_id}. Only the owner can update parameters.")
            raise typer.Exit(1)

        print_info(f"‚ö†Ô∏è Updating maximum node penalties for subnet {subnet_id} to {max_penalties}...")

        response = client.owner_update_max_penalties(subnet_id, max_penalties, key_name=key_name)

        if response.success:
            print_success(f"‚úÖ Successfully updated maximum node penalties for subnet {subnet_id} to {max_penalties}!")
            console.print(f"üìÑ Transaction Hash: [bold cyan]{response.transaction_hash}[/bold cyan]")
            if response.block_number:
                console.print(f"üì¶ Block Number: [bold cyan]#{response.block_number}[/bold cyan]")

            console.print(Panel(
                f"[bold green]‚ö†Ô∏è Maximum Node Penalties Updated![/bold green]\n\n"
                f"Subnet {subnet_id} maximum node penalties is now {max_penalties}.\n"
                f"‚Ä¢ Validators can have up to {max_penalties} penalties\n"
                f"‚Ä¢ Quality standards adjusted\n"
                f"‚Ä¢ Validator retention affected\n"
                f"‚Ä¢ Performance requirements modified\n\n"
                f"[yellow]üìä Monitor Impact:[/yellow]\n"
                f"‚Ä¢ Watch validator quality\n"
                f"‚Ä¢ Monitor penalty patterns\n"
                f"‚Ä¢ Check subnet reliability\n\n"
                f"Use: [bold]htcli subnet info --subnet-id {subnet_id}[/bold]",
                title="Maximum Penalties Update Complete",
                border_style="green"
            ))
        else:
            print_error(f"‚ùå Failed to update maximum node penalties: {response.message}")
            raise typer.Exit(1)

    except Exception as e:
        print_error(f"‚ùå Failed to update maximum node penalties: {str(e)}")
        raise typer.Exit(1)


@app.command()
def owner_add_initial_coldkeys(
    subnet_id: int = typer.Option(..., "--subnet-id", "-s", help="Subnet ID"),
    coldkeys: str = typer.Option(..., "--coldkeys", "-c", help="Comma-separated list of coldkey addresses"),
    key_name: Optional[str] = typer.Option(
        None, "--key-name", "-k", help="Key name for signing (required for owner)"
    ),
    show_guidance: bool = typer.Option(
        True, "--guidance/--no-guidance", help="Show comprehensive guidance"
    ),
):
    """Add initial coldkeys to a subnet (owner only, registration phase only)."""
    client = get_client()

    # Parse coldkeys
    coldkey_list = [addr.strip() for addr in coldkeys.split(",") if addr.strip()]

    # Show comprehensive guidance
    if show_guidance:
        from rich.panel import Panel
        guidance_panel = Panel(
            f"[bold cyan]üîë Add Initial Coldkeys Guide[/bold cyan]\n\n"
            f"This will add {len(coldkey_list)} initial coldkeys to subnet {subnet_id}:\n\n"
            f"[bold]What are Initial Coldkeys:[/bold]\n"
            f"‚Ä¢ Coldkeys that can register nodes during registration phase\n"
            f"‚Ä¢ Only these coldkeys can register before activation\n"
            f"‚Ä¢ Can be updated while subnet is in registration phase\n"
            f"‚Ä¢ Removed once subnet is activated\n\n"
            f"[bold]Impact:[/bold]\n"
            f"‚Ä¢ Controls who can register nodes initially\n"
            f"‚Ä¢ Affects subnet launch strategy\n"
            f"‚Ä¢ Influences early validator selection\n"
            f"‚Ä¢ Only available during registration phase\n\n"
            f"[yellow]‚ö†Ô∏è Important:[/yellow]\n"
            f"‚Ä¢ Only works during registration phase\n"
            f"‚Ä¢ Coldkeys are removed after activation\n"
            f"‚Ä¢ Consider your launch strategy\n"
            f"‚Ä¢ Verify coldkey addresses carefully",
            title="[bold blue]üîë Add Initial Coldkeys[/bold blue]",
            border_style="blue"
        )
        console.print(guidance_panel)
        console.print()

        # Ask for confirmation
        if not typer.confirm(f"Add {len(coldkey_list)} initial coldkeys to subnet {subnet_id}?"):
            print_info("Initial coldkeys addition cancelled.")
            return

    # Validate inputs
    if not validate_subnet_id(subnet_id):
        print_error("‚ùå Invalid subnet ID. Must be a positive integer.")
        raise typer.Exit(1)

    if not coldkey_list:
        print_error("‚ùå No valid coldkey addresses provided.")
        raise typer.Exit(1)

    for coldkey in coldkey_list:
        if not validate_coldkey_addresses(coldkey):
            print_error(f"‚ùå Invalid coldkey address: {coldkey}")
            raise typer.Exit(1)

    # Check if key_name is provided (required for owner operations)
    if not key_name:
        print_error("‚ùå Key name is required for subnet owner operations. Use --key-name to specify your signing key.")
        raise typer.Exit(1)

    try:
        # Check ownership (user must be the owner to update parameters)
        subnet_response = client.get_subnet_data(subnet_id)
        if not subnet_response.success:
            print_error(f"‚ùå Failed to get subnet information: {subnet_response.message}")
            raise typer.Exit(1)

        subnet_info = subnet_response.data

        # Check if subnet exists
        if not subnet_info.get('exists', False):
            print_error(f"‚ùå Subnet {subnet_id} does not exist.")
            raise typer.Exit(1)

        # Check ownership (user must be the owner to update parameters)
        from ..utils.ownership import get_user_addresses, user_owns_subnet
        user_addresses = get_user_addresses()
        if not user_owns_subnet(subnet_info, user_addresses):
            print_error(f"‚ùå You are not the owner of subnet {subnet_id}. Only the owner can update parameters.")
            raise typer.Exit(1)

        print_info(f"üîë Adding {len(coldkey_list)} initial coldkeys to subnet {subnet_id}...")

        response = client.owner_add_initial_coldkeys(subnet_id, coldkey_list, key_name=key_name)

        if response.success:
            print_success(f"‚úÖ Successfully added {len(coldkey_list)} initial coldkeys to subnet {subnet_id}!")
            console.print(f"üìÑ Transaction Hash: [bold cyan]{response.transaction_hash}[/bold cyan]")
            if response.block_number:
                console.print(f"üì¶ Block Number: [bold cyan]#{response.block_number}[/bold cyan]")

            console.print(Panel(
                f"[bold green]üîë Initial Coldkeys Added![/bold green]\n\n"
                f"Subnet {subnet_id} now has {len(coldkey_list)} additional initial coldkeys.\n"
                f"‚Ä¢ These coldkeys can register nodes\n"
                f"‚Ä¢ Only available during registration phase\n"
                f"‚Ä¢ Will be removed after activation\n"
                f"‚Ä¢ Launch strategy enhanced\n\n"
                f"[yellow]üìä Monitor Impact:[/yellow]\n"
                f"‚Ä¢ Watch node registration patterns\n"
                f"‚Ä¢ Monitor subnet growth\n"
                f"‚Ä¢ Check activation readiness\n\n"
                f"Use: [bold]htcli subnet info --subnet-id {subnet_id}[/bold]",
                title="Initial Coldkeys Addition Complete",
                border_style="green"
            ))
        else:
            print_error(f"‚ùå Failed to add initial coldkeys: {response.message}")
            raise typer.Exit(1)

    except Exception as e:
        print_error(f"‚ùå Failed to add initial coldkeys: {str(e)}")
        raise typer.Exit(1)


@app.command()
def owner_remove_initial_coldkeys(
    subnet_id: int = typer.Option(..., "--subnet-id", "-s", help="Subnet ID"),
    coldkeys: str = typer.Option(..., "--coldkeys", "-c", help="Comma-separated list of coldkey addresses"),
    key_name: Optional[str] = typer.Option(
        None, "--key-name", "-k", help="Key name for signing (required for owner)"
    ),
    show_guidance: bool = typer.Option(
        True, "--guidance/--no-guidance", help="Show comprehensive guidance"
    ),
):
    """Remove initial coldkeys from a subnet (owner only, registration phase only)."""
    client = get_client()

    # Parse coldkeys
    coldkey_list = [addr.strip() for addr in coldkeys.split(",") if addr.strip()]

    # Show comprehensive guidance
    if show_guidance:
        from rich.panel import Panel
        guidance_panel = Panel(
            f"[bold cyan]üîë Remove Initial Coldkeys Guide[/bold cyan]\n\n"
            f"This will remove {len(coldkey_list)} initial coldkeys from subnet {subnet_id}:\n\n"
            f"[bold]What This Does:[/bold]\n"
            f"‚Ä¢ Removes coldkeys from initial coldkeys list\n"
            f"‚Ä¢ These coldkeys can no longer register nodes\n"
            f"‚Ä¢ Only works during registration phase\n"
            f"‚Ä¢ May affect existing registered nodes\n\n"
            f"[bold]Impact:[/bold]\n"
            f"‚Ä¢ Reduces who can register nodes\n"
            f"‚Ä¢ May affect existing registrations\n"
            f"‚Ä¢ Influences subnet launch strategy\n"
            f"‚Ä¢ Only available during registration phase\n\n"
            f"[yellow]‚ö†Ô∏è Important:[/yellow]\n"
            f"‚Ä¢ Only works during registration phase\n"
            f"‚Ä¢ May affect existing nodes\n"
            f"‚Ä¢ Consider impact on registrations\n"
            f"‚Ä¢ Verify coldkey addresses carefully",
            title="[bold red]üîë Remove Initial Coldkeys[/bold red]",
            border_style="red"
        )
        console.print(guidance_panel)
        console.print()

        # Ask for confirmation
        if not typer.confirm(f"Remove {len(coldkey_list)} initial coldkeys from subnet {subnet_id}?"):
            print_info("Initial coldkeys removal cancelled.")
            return

    # Validate inputs
    if not validate_subnet_id(subnet_id):
        print_error("‚ùå Invalid subnet ID. Must be a positive integer.")
        raise typer.Exit(1)

    if not coldkey_list:
        print_error("‚ùå No valid coldkey addresses provided.")
        raise typer.Exit(1)

    for coldkey in coldkey_list:
        if not validate_coldkey_addresses(coldkey):
            print_error(f"‚ùå Invalid coldkey address: {coldkey}")
            raise typer.Exit(1)

    # Check if key_name is provided (required for owner operations)
    if not key_name:
        print_error("‚ùå Key name is required for subnet owner operations. Use --key-name to specify your signing key.")
        raise typer.Exit(1)

    try:
        # Check ownership (user must be the owner to update parameters)
        subnet_response = client.get_subnet_data(subnet_id)
        if not subnet_response.success:
            print_error(f"‚ùå Failed to get subnet information: {subnet_response.message}")
            raise typer.Exit(1)

        subnet_info = subnet_response.data

        # Check if subnet exists
        if not subnet_info.get('exists', False):
            print_error(f"‚ùå Subnet {subnet_id} does not exist.")
            raise typer.Exit(1)

        # Check ownership (user must be the owner to update parameters)
        from ..utils.ownership import get_user_addresses, user_owns_subnet
        user_addresses = get_user_addresses()
        if not user_owns_subnet(subnet_info, user_addresses):
            print_error(f"‚ùå You are not the owner of subnet {subnet_id}. Only the owner can update parameters.")
            raise typer.Exit(1)

        print_info(f"üîë Removing {len(coldkey_list)} initial coldkeys from subnet {subnet_id}...")

        response = client.owner_remove_initial_coldkeys(subnet_id, coldkey_list, key_name=key_name)

        if response.success:
            print_success(f"‚úÖ Successfully removed {len(coldkey_list)} initial coldkeys from subnet {subnet_id}!")
            console.print(f"üìÑ Transaction Hash: [bold cyan]{response.transaction_hash}[/bold cyan]")
            if response.block_number:
                console.print(f"üì¶ Block Number: [bold cyan]#{response.block_number}[/bold cyan]")

            console.print(Panel(
                f"[bold red]üîë Initial Coldkeys Removed![/bold red]\n\n"
                f"Subnet {subnet_id} has {len(coldkey_list)} fewer initial coldkeys.\n"
                f"‚Ä¢ These coldkeys can no longer register nodes\n"
                f"‚Ä¢ May affect existing registrations\n"
                f"‚Ä¢ Launch strategy modified\n"
                f"‚Ä¢ Registration access reduced\n\n"
                f"[yellow]üìä Monitor Impact:[/yellow]\n"
                f"‚Ä¢ Check existing node registrations\n"
                f"‚Ä¢ Monitor registration patterns\n"
                f"‚Ä¢ Verify launch strategy\n\n"
                f"Use: [bold]htcli subnet info --subnet-id {subnet_id}[/bold]",
                title="Initial Coldkeys Removal Complete",
                border_style="red"
            ))
        else:
            print_error(f"‚ùå Failed to remove initial coldkeys: {response.message}")
            raise typer.Exit(1)

    except Exception as e:
        print_error(f"‚ùå Failed to remove initial coldkeys: {str(e)}")
        raise typer.Exit(1)
